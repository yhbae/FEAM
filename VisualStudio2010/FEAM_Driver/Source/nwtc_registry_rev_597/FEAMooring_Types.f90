!STARTOFREGISTRYGENERATEDFILE './FEAMooring_Types.f90'

! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
!*********************************************************************************************************************************
! FEAMooring_Types
!.................................................................................................................................
! This file is part of FEAMooring.
!
! Copyright (C) 2012, 2013 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE FEAMooring_Types
! This module contains all of the user-defined types needed in FEAMooring. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  FEAM_InputFile  =======
  TYPE, PUBLIC :: FEAM_InputFile
    REAL(DbKi)  :: DT 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LEAStiff 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LMassDen 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LDMassDen 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BottmStiff 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LRadAnch 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LAngAnch 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LDpthAnch 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LRadFair 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LAngFair 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LDrftFair 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LUnstrLen 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Tension 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GSL 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GSR 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GE 
    INTEGER(IntKi)  :: NumLines 
    INTEGER(IntKi)  :: NumElems 
    REAL(ReKi)  :: Eps 
    REAL(ReKi)  :: Gravity 
    REAL(ReKi)  :: WtrDens 
    INTEGER(IntKi)  :: MaxIter 
    LOGICAL  :: SumPrint 
    INTEGER(IntKi)  :: OutFile 
    LOGICAL  :: TabDelim 
    CHARACTER(20)  :: OutFmt 
    REAL(DbKi)  :: Tstart 
    INTEGER(IntKi)  :: NumOuts 
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: OutList 
  END TYPE FEAM_InputFile
! =======================
! =========  FEAM_InitInputType  =======
  TYPE, PUBLIC :: FEAM_InitInputType
    CHARACTER(1024)  :: InputFile 
    CHARACTER(1024)  :: RootName 
    REAL(ReKi) , DIMENSION(1:6)  :: PtfmInit 
  END TYPE FEAM_InitInputType
! =======================
! =========  FEAM_InitOutputType  =======
  TYPE, PUBLIC :: FEAM_InitOutputType
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr 
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt 
    TYPE(ProgDesc)  :: Ver 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LAnchxi 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LAnchyi 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LAnchzi 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LFairxt 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LFairyt 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LFairzt 
  END TYPE FEAM_InitOutputType
! =======================
! =========  FEAM_ContinuousStateType  =======
  TYPE, PUBLIC :: FEAM_ContinuousStateType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GLU 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GLDU 
  END TYPE FEAM_ContinuousStateType
! =======================
! =========  FEAM_DiscreteStateType  =======
  TYPE, PUBLIC :: FEAM_DiscreteStateType
    REAL(ReKi)  :: DummyDiscState 
  END TYPE FEAM_DiscreteStateType
! =======================
! =========  FEAM_ConstraintStateType  =======
  TYPE, PUBLIC :: FEAM_ConstraintStateType
    REAL(ReKi) , DIMENSION(1:3)  :: TSN 
    REAL(ReKi) , DIMENSION(1:3)  :: TZER 
  END TYPE FEAM_ConstraintStateType
! =======================
! =========  FEAM_OtherStateType  =======
  TYPE, PUBLIC :: FEAM_OtherStateType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GLU0 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GLDDU 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GLF 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GLK 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GLUZR 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GTZER 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GFORC0 
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: GMASS0 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FAST_FP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FAST_FPA 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FAIR_T 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FAST_RP 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ANCH_T 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FAIR_ANG 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ANCH_ANG 
    REAL(ReKi) , DIMENSION(1:15,1:15)  :: ESTIF 
    REAL(ReKi) , DIMENSION(1:15,1:15)  :: EMASS 
    REAL(ReKi) , DIMENSION(1:15)  :: FORCE 
    REAL(ReKi) , DIMENSION(1:15)  :: RSDF 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_Lines 
    REAL(ReKi) , DIMENSION(1:3,1:4)  :: U 
    REAL(ReKi) , DIMENSION(1:3,1:4)  :: U0 
    REAL(ReKi) , DIMENSION(1:3,1:4)  :: DU 
    REAL(ReKi) , DIMENSION(1:3,1:4)  :: DDU 
    REAL(ReKi) , DIMENSION(1:15)  :: FORC0 
    REAL(ReKi) , DIMENSION(1:15,1:15)  :: EMAS0 
    INTEGER(IntKi)  :: INCR 
    LOGICAL  :: BottomTouch 
    LOGICAL  :: Iteration1 
    LOGICAL  :: Iteration2 
    REAL(ReKi) , DIMENSION(1:3)  :: R 
    REAL(ReKi) , DIMENSION(1:3)  :: RP 
    REAL(ReKi) , DIMENSION(1:3)  :: FP 
    REAL(ReKi) , DIMENSION(1:3)  :: SLIN 
    REAL(ReKi) , DIMENSION(1:6,1:6)  :: STIFR 
    REAL(ReKi) , DIMENSION(1:6)  :: RHSR 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Line_Coordinate 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Line_Tangent 
  END TYPE FEAM_OtherStateType
! =======================
! =========  FEAM_ParameterType  =======
  TYPE, PUBLIC :: FEAM_ParameterType
    REAL(DbKi)  :: DT 
    REAL(ReKi) , DIMENSION(1:3)  :: GRAV 
    REAL(ReKi)  :: Eps 
    REAL(ReKi)  :: Gravity 
    REAL(ReKi)  :: WtrDens 
    INTEGER(IntKi)  :: MaxIter 
    INTEGER(IntKi)  :: NHBD 
    INTEGER(IntKi)  :: NDIM 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NEQ 
    INTEGER(IntKi)  :: NBAND 
    LOGICAL  :: DYN 
    INTEGER(IntKi)  :: NumLines 
    INTEGER(IntKi)  :: NumElems 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GSL 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GP 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Elength 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BottmElev 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BottmStiff 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LMassDen 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LDMassDen 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LEAStiff 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Bvp 
    REAL(ReKi) , DIMENSION(1:6,1:4)  :: SHAP 
    REAL(ReKi) , DIMENSION(1:6,1:4)  :: SHAPS 
    REAL(ReKi) , DIMENSION(1:6)  :: GAUSSW 
    INTEGER(IntKi)  :: NGAUSS 
    REAL(ReKi) , DIMENSION(1:10,1:4)  :: SHAPT 
    REAL(ReKi) , DIMENSION(1:10,1:4)  :: SHAPTS 
    REAL(ReKi)  :: NTRAP 
    REAL(ReKi) , DIMENSION(1:4,1:4)  :: SBEND 
    REAL(ReKi) , DIMENSION(1:3,1:4,1:4)  :: STEN 
    REAL(ReKi) , DIMENSION(1:4,1:4)  :: RMASS 
    REAL(ReKi) , DIMENSION(1:4,1:4,1:4,1:4)  :: RADDM 
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: PMPN 
    REAL(ReKi) , DIMENSION(1:4)  :: AM 
    REAL(ReKi) , DIMENSION(1:3)  :: PM 
    INTEGER(IntKi) , DIMENSION(1:3,1:4)  :: IDOF 
    INTEGER(IntKi) , DIMENSION(1:3)  :: JDOF 
    REAL(ReKi) , DIMENSION(1:3,1:3,1:4)  :: PPA 
    REAL(ReKi)  :: PtfmRefzt 
    INTEGER(IntKi)  :: NumOuts 
    CHARACTER(1024)  :: RootName 
    TYPE(OutParmType) , DIMENSION(:), ALLOCATABLE  :: OutParam 
    CHARACTER(1)  :: Delim 
  END TYPE FEAM_ParameterType
! =======================
! =========  FEAM_InputType  =======
  TYPE, PUBLIC :: FEAM_InputType
    TYPE(MeshType)  :: HydroForceLineMesh 
    TYPE(MeshType)  :: PtFairleadDisplacement 
  END TYPE FEAM_InputType
! =======================
! =========  FEAM_OutputType  =======
  TYPE, PUBLIC :: FEAM_OutputType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput 
    TYPE(MeshType)  :: PtFairleadLoad 
    TYPE(MeshType)  :: LineMeshPosition 
  END TYPE FEAM_OutputType
! =======================
CONTAINS
 SUBROUTINE FEAM_Copyinputfile( SrcinputfileData, DstinputfileData, CtrlCode, ErrStat, ErrMsg )
   TYPE(feam_inputfile), INTENT(INOUT) :: SrcinputfileData
   TYPE(feam_inputfile), INTENT(INOUT) :: DstinputfileData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstinputfileData%DT = SrcinputfileData%DT
IF (ALLOCATED(SrcinputfileData%LEAStiff)) THEN
   i1_l = LBOUND(SrcinputfileData%LEAStiff,1)
   i1_u = UBOUND(SrcinputfileData%LEAStiff,1)
   IF (.NOT.ALLOCATED(DstinputfileData%LEAStiff)) THEN 
      ALLOCATE(DstinputfileData%LEAStiff(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_Copyinputfile: Error allocating DstinputfileData%LEAStiff.'
         RETURN
      END IF
   END IF
   DstinputfileData%LEAStiff = SrcinputfileData%LEAStiff
ENDIF
IF (ALLOCATED(SrcinputfileData%LMassDen)) THEN
   i1_l = LBOUND(SrcinputfileData%LMassDen,1)
   i1_u = UBOUND(SrcinputfileData%LMassDen,1)
   IF (.NOT.ALLOCATED(DstinputfileData%LMassDen)) THEN 
      ALLOCATE(DstinputfileData%LMassDen(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_Copyinputfile: Error allocating DstinputfileData%LMassDen.'
         RETURN
      END IF
   END IF
   DstinputfileData%LMassDen = SrcinputfileData%LMassDen
ENDIF
IF (ALLOCATED(SrcinputfileData%LDMassDen)) THEN
   i1_l = LBOUND(SrcinputfileData%LDMassDen,1)
   i1_u = UBOUND(SrcinputfileData%LDMassDen,1)
   IF (.NOT.ALLOCATED(DstinputfileData%LDMassDen)) THEN 
      ALLOCATE(DstinputfileData%LDMassDen(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_Copyinputfile: Error allocating DstinputfileData%LDMassDen.'
         RETURN
      END IF
   END IF
   DstinputfileData%LDMassDen = SrcinputfileData%LDMassDen
ENDIF
IF (ALLOCATED(SrcinputfileData%BottmStiff)) THEN
   i1_l = LBOUND(SrcinputfileData%BottmStiff,1)
   i1_u = UBOUND(SrcinputfileData%BottmStiff,1)
   IF (.NOT.ALLOCATED(DstinputfileData%BottmStiff)) THEN 
      ALLOCATE(DstinputfileData%BottmStiff(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_Copyinputfile: Error allocating DstinputfileData%BottmStiff.'
         RETURN
      END IF
   END IF
   DstinputfileData%BottmStiff = SrcinputfileData%BottmStiff
ENDIF
IF (ALLOCATED(SrcinputfileData%LRadAnch)) THEN
   i1_l = LBOUND(SrcinputfileData%LRadAnch,1)
   i1_u = UBOUND(SrcinputfileData%LRadAnch,1)
   IF (.NOT.ALLOCATED(DstinputfileData%LRadAnch)) THEN 
      ALLOCATE(DstinputfileData%LRadAnch(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_Copyinputfile: Error allocating DstinputfileData%LRadAnch.'
         RETURN
      END IF
   END IF
   DstinputfileData%LRadAnch = SrcinputfileData%LRadAnch
ENDIF
IF (ALLOCATED(SrcinputfileData%LAngAnch)) THEN
   i1_l = LBOUND(SrcinputfileData%LAngAnch,1)
   i1_u = UBOUND(SrcinputfileData%LAngAnch,1)
   IF (.NOT.ALLOCATED(DstinputfileData%LAngAnch)) THEN 
      ALLOCATE(DstinputfileData%LAngAnch(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_Copyinputfile: Error allocating DstinputfileData%LAngAnch.'
         RETURN
      END IF
   END IF
   DstinputfileData%LAngAnch = SrcinputfileData%LAngAnch
ENDIF
IF (ALLOCATED(SrcinputfileData%LDpthAnch)) THEN
   i1_l = LBOUND(SrcinputfileData%LDpthAnch,1)
   i1_u = UBOUND(SrcinputfileData%LDpthAnch,1)
   IF (.NOT.ALLOCATED(DstinputfileData%LDpthAnch)) THEN 
      ALLOCATE(DstinputfileData%LDpthAnch(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_Copyinputfile: Error allocating DstinputfileData%LDpthAnch.'
         RETURN
      END IF
   END IF
   DstinputfileData%LDpthAnch = SrcinputfileData%LDpthAnch
ENDIF
IF (ALLOCATED(SrcinputfileData%LRadFair)) THEN
   i1_l = LBOUND(SrcinputfileData%LRadFair,1)
   i1_u = UBOUND(SrcinputfileData%LRadFair,1)
   IF (.NOT.ALLOCATED(DstinputfileData%LRadFair)) THEN 
      ALLOCATE(DstinputfileData%LRadFair(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_Copyinputfile: Error allocating DstinputfileData%LRadFair.'
         RETURN
      END IF
   END IF
   DstinputfileData%LRadFair = SrcinputfileData%LRadFair
ENDIF
IF (ALLOCATED(SrcinputfileData%LAngFair)) THEN
   i1_l = LBOUND(SrcinputfileData%LAngFair,1)
   i1_u = UBOUND(SrcinputfileData%LAngFair,1)
   IF (.NOT.ALLOCATED(DstinputfileData%LAngFair)) THEN 
      ALLOCATE(DstinputfileData%LAngFair(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_Copyinputfile: Error allocating DstinputfileData%LAngFair.'
         RETURN
      END IF
   END IF
   DstinputfileData%LAngFair = SrcinputfileData%LAngFair
ENDIF
IF (ALLOCATED(SrcinputfileData%LDrftFair)) THEN
   i1_l = LBOUND(SrcinputfileData%LDrftFair,1)
   i1_u = UBOUND(SrcinputfileData%LDrftFair,1)
   IF (.NOT.ALLOCATED(DstinputfileData%LDrftFair)) THEN 
      ALLOCATE(DstinputfileData%LDrftFair(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_Copyinputfile: Error allocating DstinputfileData%LDrftFair.'
         RETURN
      END IF
   END IF
   DstinputfileData%LDrftFair = SrcinputfileData%LDrftFair
ENDIF
IF (ALLOCATED(SrcinputfileData%LUnstrLen)) THEN
   i1_l = LBOUND(SrcinputfileData%LUnstrLen,1)
   i1_u = UBOUND(SrcinputfileData%LUnstrLen,1)
   IF (.NOT.ALLOCATED(DstinputfileData%LUnstrLen)) THEN 
      ALLOCATE(DstinputfileData%LUnstrLen(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_Copyinputfile: Error allocating DstinputfileData%LUnstrLen.'
         RETURN
      END IF
   END IF
   DstinputfileData%LUnstrLen = SrcinputfileData%LUnstrLen
ENDIF
IF (ALLOCATED(SrcinputfileData%Tension)) THEN
   i1_l = LBOUND(SrcinputfileData%Tension,1)
   i1_u = UBOUND(SrcinputfileData%Tension,1)
   IF (.NOT.ALLOCATED(DstinputfileData%Tension)) THEN 
      ALLOCATE(DstinputfileData%Tension(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_Copyinputfile: Error allocating DstinputfileData%Tension.'
         RETURN
      END IF
   END IF
   DstinputfileData%Tension = SrcinputfileData%Tension
ENDIF
IF (ALLOCATED(SrcinputfileData%GSL)) THEN
   i1_l = LBOUND(SrcinputfileData%GSL,1)
   i1_u = UBOUND(SrcinputfileData%GSL,1)
   i2_l = LBOUND(SrcinputfileData%GSL,2)
   i2_u = UBOUND(SrcinputfileData%GSL,2)
   i3_l = LBOUND(SrcinputfileData%GSL,3)
   i3_u = UBOUND(SrcinputfileData%GSL,3)
   IF (.NOT.ALLOCATED(DstinputfileData%GSL)) THEN 
      ALLOCATE(DstinputfileData%GSL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_Copyinputfile: Error allocating DstinputfileData%GSL.'
         RETURN
      END IF
   END IF
   DstinputfileData%GSL = SrcinputfileData%GSL
ENDIF
IF (ALLOCATED(SrcinputfileData%GSR)) THEN
   i1_l = LBOUND(SrcinputfileData%GSR,1)
   i1_u = UBOUND(SrcinputfileData%GSR,1)
   i2_l = LBOUND(SrcinputfileData%GSR,2)
   i2_u = UBOUND(SrcinputfileData%GSR,2)
   IF (.NOT.ALLOCATED(DstinputfileData%GSR)) THEN 
      ALLOCATE(DstinputfileData%GSR(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_Copyinputfile: Error allocating DstinputfileData%GSR.'
         RETURN
      END IF
   END IF
   DstinputfileData%GSR = SrcinputfileData%GSR
ENDIF
IF (ALLOCATED(SrcinputfileData%GE)) THEN
   i1_l = LBOUND(SrcinputfileData%GE,1)
   i1_u = UBOUND(SrcinputfileData%GE,1)
   i2_l = LBOUND(SrcinputfileData%GE,2)
   i2_u = UBOUND(SrcinputfileData%GE,2)
   i3_l = LBOUND(SrcinputfileData%GE,3)
   i3_u = UBOUND(SrcinputfileData%GE,3)
   IF (.NOT.ALLOCATED(DstinputfileData%GE)) THEN 
      ALLOCATE(DstinputfileData%GE(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_Copyinputfile: Error allocating DstinputfileData%GE.'
         RETURN
      END IF
   END IF
   DstinputfileData%GE = SrcinputfileData%GE
ENDIF
   DstinputfileData%NumLines = SrcinputfileData%NumLines
   DstinputfileData%NumElems = SrcinputfileData%NumElems
   DstinputfileData%Eps = SrcinputfileData%Eps
   DstinputfileData%Gravity = SrcinputfileData%Gravity
   DstinputfileData%WtrDens = SrcinputfileData%WtrDens
   DstinputfileData%MaxIter = SrcinputfileData%MaxIter
   DstinputfileData%SumPrint = SrcinputfileData%SumPrint
   DstinputfileData%OutFile = SrcinputfileData%OutFile
   DstinputfileData%TabDelim = SrcinputfileData%TabDelim
   DstinputfileData%OutFmt = SrcinputfileData%OutFmt
   DstinputfileData%Tstart = SrcinputfileData%Tstart
   DstinputfileData%NumOuts = SrcinputfileData%NumOuts
IF (ALLOCATED(SrcinputfileData%OutList)) THEN
   i1_l = LBOUND(SrcinputfileData%OutList,1)
   i1_u = UBOUND(SrcinputfileData%OutList,1)
   IF (.NOT.ALLOCATED(DstinputfileData%OutList)) THEN 
      ALLOCATE(DstinputfileData%OutList(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_Copyinputfile: Error allocating DstinputfileData%OutList.'
         RETURN
      END IF
   END IF
   DstinputfileData%OutList = SrcinputfileData%OutList
ENDIF
 END SUBROUTINE FEAM_Copyinputfile

 SUBROUTINE FEAM_Destroyinputfile( inputfileData, ErrStat, ErrMsg )
  TYPE(feam_inputfile), INTENT(INOUT) :: inputfileData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(inputfileData%LEAStiff)) THEN
   DEALLOCATE(inputfileData%LEAStiff)
ENDIF
IF (ALLOCATED(inputfileData%LMassDen)) THEN
   DEALLOCATE(inputfileData%LMassDen)
ENDIF
IF (ALLOCATED(inputfileData%LDMassDen)) THEN
   DEALLOCATE(inputfileData%LDMassDen)
ENDIF
IF (ALLOCATED(inputfileData%BottmStiff)) THEN
   DEALLOCATE(inputfileData%BottmStiff)
ENDIF
IF (ALLOCATED(inputfileData%LRadAnch)) THEN
   DEALLOCATE(inputfileData%LRadAnch)
ENDIF
IF (ALLOCATED(inputfileData%LAngAnch)) THEN
   DEALLOCATE(inputfileData%LAngAnch)
ENDIF
IF (ALLOCATED(inputfileData%LDpthAnch)) THEN
   DEALLOCATE(inputfileData%LDpthAnch)
ENDIF
IF (ALLOCATED(inputfileData%LRadFair)) THEN
   DEALLOCATE(inputfileData%LRadFair)
ENDIF
IF (ALLOCATED(inputfileData%LAngFair)) THEN
   DEALLOCATE(inputfileData%LAngFair)
ENDIF
IF (ALLOCATED(inputfileData%LDrftFair)) THEN
   DEALLOCATE(inputfileData%LDrftFair)
ENDIF
IF (ALLOCATED(inputfileData%LUnstrLen)) THEN
   DEALLOCATE(inputfileData%LUnstrLen)
ENDIF
IF (ALLOCATED(inputfileData%Tension)) THEN
   DEALLOCATE(inputfileData%Tension)
ENDIF
IF (ALLOCATED(inputfileData%GSL)) THEN
   DEALLOCATE(inputfileData%GSL)
ENDIF
IF (ALLOCATED(inputfileData%GSR)) THEN
   DEALLOCATE(inputfileData%GSR)
ENDIF
IF (ALLOCATED(inputfileData%GE)) THEN
   DEALLOCATE(inputfileData%GE)
ENDIF
IF (ALLOCATED(inputfileData%OutList)) THEN
   DEALLOCATE(inputfileData%OutList)
ENDIF
 END SUBROUTINE FEAM_Destroyinputfile

 SUBROUTINE FEAM_Packinputfile( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(feam_inputfile),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! DT
  Re_BufSz    = Re_BufSz    + SIZE( InData%LEAStiff )  ! LEAStiff 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LMassDen )  ! LMassDen 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LDMassDen )  ! LDMassDen 
  Re_BufSz    = Re_BufSz    + SIZE( InData%BottmStiff )  ! BottmStiff 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LRadAnch )  ! LRadAnch 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LAngAnch )  ! LAngAnch 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LDpthAnch )  ! LDpthAnch 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LRadFair )  ! LRadFair 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LAngFair )  ! LAngFair 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LDrftFair )  ! LDrftFair 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LUnstrLen )  ! LUnstrLen 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Tension )  ! Tension 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GSL )  ! GSL 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GSR )  ! GSR 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GE )  ! GE 
  Int_BufSz  = Int_BufSz  + 1  ! NumLines
  Int_BufSz  = Int_BufSz  + 1  ! NumElems
  Re_BufSz   = Re_BufSz   + 1  ! Eps
  Re_BufSz   = Re_BufSz   + 1  ! Gravity
  Re_BufSz   = Re_BufSz   + 1  ! WtrDens
  Int_BufSz  = Int_BufSz  + 1  ! MaxIter
  Int_BufSz  = Int_BufSz  + 1  ! OutFile
  Db_BufSz   = Db_BufSz   + 1  ! Tstart
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%DT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(InData%LEAStiff) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LEAStiff))-1 ) =  PACK(InData%LEAStiff ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LEAStiff)
  ENDIF
  IF ( ALLOCATED(InData%LMassDen) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LMassDen))-1 ) =  PACK(InData%LMassDen ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LMassDen)
  ENDIF
  IF ( ALLOCATED(InData%LDMassDen) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LDMassDen))-1 ) =  PACK(InData%LDMassDen ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LDMassDen)
  ENDIF
  IF ( ALLOCATED(InData%BottmStiff) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%BottmStiff))-1 ) =  PACK(InData%BottmStiff ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%BottmStiff)
  ENDIF
  IF ( ALLOCATED(InData%LRadAnch) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LRadAnch))-1 ) =  PACK(InData%LRadAnch ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LRadAnch)
  ENDIF
  IF ( ALLOCATED(InData%LAngAnch) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LAngAnch))-1 ) =  PACK(InData%LAngAnch ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LAngAnch)
  ENDIF
  IF ( ALLOCATED(InData%LDpthAnch) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LDpthAnch))-1 ) =  PACK(InData%LDpthAnch ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LDpthAnch)
  ENDIF
  IF ( ALLOCATED(InData%LRadFair) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LRadFair))-1 ) =  PACK(InData%LRadFair ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LRadFair)
  ENDIF
  IF ( ALLOCATED(InData%LAngFair) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LAngFair))-1 ) =  PACK(InData%LAngFair ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LAngFair)
  ENDIF
  IF ( ALLOCATED(InData%LDrftFair) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LDrftFair))-1 ) =  PACK(InData%LDrftFair ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LDrftFair)
  ENDIF
  IF ( ALLOCATED(InData%LUnstrLen) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LUnstrLen))-1 ) =  PACK(InData%LUnstrLen ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LUnstrLen)
  ENDIF
  IF ( ALLOCATED(InData%Tension) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Tension))-1 ) =  PACK(InData%Tension ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Tension)
  ENDIF
  IF ( ALLOCATED(InData%GSL) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GSL))-1 ) =  PACK(InData%GSL ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GSL)
  ENDIF
  IF ( ALLOCATED(InData%GSR) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GSR))-1 ) =  PACK(InData%GSR ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GSR)
  ENDIF
  IF ( ALLOCATED(InData%GE) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GE))-1 ) =  PACK(InData%GE ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GE)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumLines )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumElems )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Eps )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Gravity )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WtrDens )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MaxIter )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutFile )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%Tstart )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE FEAM_Packinputfile

 SUBROUTINE FEAM_UnPackinputfile( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(feam_inputfile), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(OutData%LEAStiff) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LEAStiff,1))); mask1 = .TRUE.
    OutData%LEAStiff = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LEAStiff))-1 ),mask1,OutData%LEAStiff)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LEAStiff)
  ENDIF
  IF ( ALLOCATED(OutData%LMassDen) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LMassDen,1))); mask1 = .TRUE.
    OutData%LMassDen = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LMassDen))-1 ),mask1,OutData%LMassDen)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LMassDen)
  ENDIF
  IF ( ALLOCATED(OutData%LDMassDen) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LDMassDen,1))); mask1 = .TRUE.
    OutData%LDMassDen = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LDMassDen))-1 ),mask1,OutData%LDMassDen)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LDMassDen)
  ENDIF
  IF ( ALLOCATED(OutData%BottmStiff) ) THEN
  ALLOCATE(mask1(SIZE(OutData%BottmStiff,1))); mask1 = .TRUE.
    OutData%BottmStiff = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%BottmStiff))-1 ),mask1,OutData%BottmStiff)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%BottmStiff)
  ENDIF
  IF ( ALLOCATED(OutData%LRadAnch) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LRadAnch,1))); mask1 = .TRUE.
    OutData%LRadAnch = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LRadAnch))-1 ),mask1,OutData%LRadAnch)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LRadAnch)
  ENDIF
  IF ( ALLOCATED(OutData%LAngAnch) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LAngAnch,1))); mask1 = .TRUE.
    OutData%LAngAnch = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LAngAnch))-1 ),mask1,OutData%LAngAnch)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LAngAnch)
  ENDIF
  IF ( ALLOCATED(OutData%LDpthAnch) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LDpthAnch,1))); mask1 = .TRUE.
    OutData%LDpthAnch = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LDpthAnch))-1 ),mask1,OutData%LDpthAnch)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LDpthAnch)
  ENDIF
  IF ( ALLOCATED(OutData%LRadFair) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LRadFair,1))); mask1 = .TRUE.
    OutData%LRadFair = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LRadFair))-1 ),mask1,OutData%LRadFair)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LRadFair)
  ENDIF
  IF ( ALLOCATED(OutData%LAngFair) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LAngFair,1))); mask1 = .TRUE.
    OutData%LAngFair = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LAngFair))-1 ),mask1,OutData%LAngFair)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LAngFair)
  ENDIF
  IF ( ALLOCATED(OutData%LDrftFair) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LDrftFair,1))); mask1 = .TRUE.
    OutData%LDrftFair = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LDrftFair))-1 ),mask1,OutData%LDrftFair)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LDrftFair)
  ENDIF
  IF ( ALLOCATED(OutData%LUnstrLen) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LUnstrLen,1))); mask1 = .TRUE.
    OutData%LUnstrLen = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LUnstrLen))-1 ),mask1,OutData%LUnstrLen)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LUnstrLen)
  ENDIF
  IF ( ALLOCATED(OutData%Tension) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Tension,1))); mask1 = .TRUE.
    OutData%Tension = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Tension))-1 ),mask1,OutData%Tension)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Tension)
  ENDIF
  IF ( ALLOCATED(OutData%GSL) ) THEN
  ALLOCATE(mask3(SIZE(OutData%GSL,1),SIZE(OutData%GSL,2),SIZE(OutData%GSL,3))); mask3 = .TRUE.
    OutData%GSL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GSL))-1 ),mask3,OutData%GSL)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GSL)
  ENDIF
  IF ( ALLOCATED(OutData%GSR) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GSR,1),SIZE(OutData%GSR,2))); mask2 = .TRUE.
    OutData%GSR = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GSR))-1 ),mask2,OutData%GSR)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GSR)
  ENDIF
  IF ( ALLOCATED(OutData%GE) ) THEN
  ALLOCATE(mask3(SIZE(OutData%GE,1),SIZE(OutData%GE,2),SIZE(OutData%GE,3))); mask3 = .TRUE.
    OutData%GE = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GE))-1 ),mask3,OutData%GE)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GE)
  ENDIF
  OutData%NumLines = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumElems = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%Eps = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Gravity = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WtrDens = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MaxIter = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%OutFile = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%Tstart = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnPackinputfile

 SUBROUTINE FEAM_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_initinputtype), INTENT(INOUT) :: SrcInitInputData
   TYPE(FEAM_initinputtype), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitInputData%InputFile = SrcInitInputData%InputFile
   DstInitInputData%RootName = SrcInitInputData%RootName
   DstInitInputData%PtfmInit = SrcInitInputData%PtfmInit
 END SUBROUTINE FEAM_CopyInitInput

 SUBROUTINE FEAM_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(FEAM_initinputtype), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE FEAM_DestroyInitInput

 SUBROUTINE FEAM_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_initinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%PtfmInit )  ! PtfmInit 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PtfmInit))-1 ) =  PACK(InData%PtfmInit ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%PtfmInit)
 END SUBROUTINE FEAM_PackInitInput

 SUBROUTINE FEAM_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_initinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  ALLOCATE(mask1(SIZE(OutData%PtfmInit,1))); mask1 = .TRUE.
  OutData%PtfmInit = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PtfmInit))-1 ),mask1,OutData%PtfmInit)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%PtfmInit)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnPackInitInput

 SUBROUTINE FEAM_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_initoutputtype), INTENT(INOUT) :: SrcInitOutputData
   TYPE(FEAM_initoutputtype), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInitOutputData%WriteOutputHdr)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputHdr,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputHdr,1)
   IF (.NOT.ALLOCATED(DstInitOutputData%WriteOutputHdr)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyInitOutput: Error allocating DstInitOutputData%WriteOutputHdr.'
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputUnt)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputUnt,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputUnt,1)
   IF (.NOT.ALLOCATED(DstInitOutputData%WriteOutputUnt)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyInitOutput: Error allocating DstInitOutputData%WriteOutputUnt.'
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat, ErrMsg )
IF (ALLOCATED(SrcInitOutputData%LAnchxi)) THEN
   i1_l = LBOUND(SrcInitOutputData%LAnchxi,1)
   i1_u = UBOUND(SrcInitOutputData%LAnchxi,1)
   IF (.NOT.ALLOCATED(DstInitOutputData%LAnchxi)) THEN 
      ALLOCATE(DstInitOutputData%LAnchxi(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyInitOutput: Error allocating DstInitOutputData%LAnchxi.'
         RETURN
      END IF
   END IF
   DstInitOutputData%LAnchxi = SrcInitOutputData%LAnchxi
ENDIF
IF (ALLOCATED(SrcInitOutputData%LAnchyi)) THEN
   i1_l = LBOUND(SrcInitOutputData%LAnchyi,1)
   i1_u = UBOUND(SrcInitOutputData%LAnchyi,1)
   IF (.NOT.ALLOCATED(DstInitOutputData%LAnchyi)) THEN 
      ALLOCATE(DstInitOutputData%LAnchyi(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyInitOutput: Error allocating DstInitOutputData%LAnchyi.'
         RETURN
      END IF
   END IF
   DstInitOutputData%LAnchyi = SrcInitOutputData%LAnchyi
ENDIF
IF (ALLOCATED(SrcInitOutputData%LAnchzi)) THEN
   i1_l = LBOUND(SrcInitOutputData%LAnchzi,1)
   i1_u = UBOUND(SrcInitOutputData%LAnchzi,1)
   IF (.NOT.ALLOCATED(DstInitOutputData%LAnchzi)) THEN 
      ALLOCATE(DstInitOutputData%LAnchzi(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyInitOutput: Error allocating DstInitOutputData%LAnchzi.'
         RETURN
      END IF
   END IF
   DstInitOutputData%LAnchzi = SrcInitOutputData%LAnchzi
ENDIF
IF (ALLOCATED(SrcInitOutputData%LFairxt)) THEN
   i1_l = LBOUND(SrcInitOutputData%LFairxt,1)
   i1_u = UBOUND(SrcInitOutputData%LFairxt,1)
   IF (.NOT.ALLOCATED(DstInitOutputData%LFairxt)) THEN 
      ALLOCATE(DstInitOutputData%LFairxt(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyInitOutput: Error allocating DstInitOutputData%LFairxt.'
         RETURN
      END IF
   END IF
   DstInitOutputData%LFairxt = SrcInitOutputData%LFairxt
ENDIF
IF (ALLOCATED(SrcInitOutputData%LFairyt)) THEN
   i1_l = LBOUND(SrcInitOutputData%LFairyt,1)
   i1_u = UBOUND(SrcInitOutputData%LFairyt,1)
   IF (.NOT.ALLOCATED(DstInitOutputData%LFairyt)) THEN 
      ALLOCATE(DstInitOutputData%LFairyt(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyInitOutput: Error allocating DstInitOutputData%LFairyt.'
         RETURN
      END IF
   END IF
   DstInitOutputData%LFairyt = SrcInitOutputData%LFairyt
ENDIF
IF (ALLOCATED(SrcInitOutputData%LFairzt)) THEN
   i1_l = LBOUND(SrcInitOutputData%LFairzt,1)
   i1_u = UBOUND(SrcInitOutputData%LFairzt,1)
   IF (.NOT.ALLOCATED(DstInitOutputData%LFairzt)) THEN 
      ALLOCATE(DstInitOutputData%LFairzt(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyInitOutput: Error allocating DstInitOutputData%LFairzt.'
         RETURN
      END IF
   END IF
   DstInitOutputData%LFairzt = SrcInitOutputData%LFairzt
ENDIF
 END SUBROUTINE FEAM_CopyInitOutput

 SUBROUTINE FEAM_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(FEAM_initoutputtype), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitOutputData%WriteOutputHdr)) THEN
   DEALLOCATE(InitOutputData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputUnt)) THEN
   DEALLOCATE(InitOutputData%WriteOutputUnt)
ENDIF
  CALL NWTC_Library_Destroyprogdesc( InitOutputData%Ver, ErrStat, ErrMsg )
IF (ALLOCATED(InitOutputData%LAnchxi)) THEN
   DEALLOCATE(InitOutputData%LAnchxi)
ENDIF
IF (ALLOCATED(InitOutputData%LAnchyi)) THEN
   DEALLOCATE(InitOutputData%LAnchyi)
ENDIF
IF (ALLOCATED(InitOutputData%LAnchzi)) THEN
   DEALLOCATE(InitOutputData%LAnchzi)
ENDIF
IF (ALLOCATED(InitOutputData%LFairxt)) THEN
   DEALLOCATE(InitOutputData%LFairxt)
ENDIF
IF (ALLOCATED(InitOutputData%LFairyt)) THEN
   DEALLOCATE(InitOutputData%LFairyt)
ENDIF
IF (ALLOCATED(InitOutputData%LFairzt)) THEN
   DEALLOCATE(InitOutputData%LFairzt)
ENDIF
 END SUBROUTINE FEAM_DestroyInitOutput

 SUBROUTINE FEAM_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_initoutputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Ver_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Db_Ver_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Int_Ver_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Ver_Buf ) ! Ver
  IF(ALLOCATED(Re_Ver_Buf))  DEALLOCATE(Re_Ver_Buf)
  IF(ALLOCATED(Db_Ver_Buf))  DEALLOCATE(Db_Ver_Buf)
  IF(ALLOCATED(Int_Ver_Buf)) DEALLOCATE(Int_Ver_Buf)
  Re_BufSz    = Re_BufSz    + SIZE( InData%LAnchxi )  ! LAnchxi 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LAnchyi )  ! LAnchyi 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LAnchzi )  ! LAnchzi 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LFairxt )  ! LFairxt 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LFairyt )  ! LFairyt 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LFairzt )  ! LFairzt 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, OnlySize ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 ) = Re_Ver_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 ) = Db_Ver_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 ) = Int_Ver_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  IF( ALLOCATED(Re_Ver_Buf) )  DEALLOCATE(Re_Ver_Buf)
  IF( ALLOCATED(Db_Ver_Buf) )  DEALLOCATE(Db_Ver_Buf)
  IF( ALLOCATED(Int_Ver_Buf) ) DEALLOCATE(Int_Ver_Buf)
  IF ( ALLOCATED(InData%LAnchxi) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LAnchxi))-1 ) =  PACK(InData%LAnchxi ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LAnchxi)
  ENDIF
  IF ( ALLOCATED(InData%LAnchyi) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LAnchyi))-1 ) =  PACK(InData%LAnchyi ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LAnchyi)
  ENDIF
  IF ( ALLOCATED(InData%LAnchzi) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LAnchzi))-1 ) =  PACK(InData%LAnchzi ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LAnchzi)
  ENDIF
  IF ( ALLOCATED(InData%LFairxt) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LFairxt))-1 ) =  PACK(InData%LFairxt ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LFairxt)
  ENDIF
  IF ( ALLOCATED(InData%LFairyt) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LFairyt))-1 ) =  PACK(InData%LFairyt ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LFairyt)
  ENDIF
  IF ( ALLOCATED(InData%LFairzt) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LFairzt))-1 ) =  PACK(InData%LFairzt ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LFairzt)
  ENDIF
 END SUBROUTINE FEAM_PackInitOutput

 SUBROUTINE FEAM_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_initoutputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Ver_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call NWTC_Library_Packprogdesc to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    Re_Ver_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    Db_Ver_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    Int_Ver_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  CALL NWTC_Library_UnPackprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg ) ! Ver 
  IF ( ALLOCATED(OutData%LAnchxi) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LAnchxi,1))); mask1 = .TRUE.
    OutData%LAnchxi = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LAnchxi))-1 ),mask1,OutData%LAnchxi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LAnchxi)
  ENDIF
  IF ( ALLOCATED(OutData%LAnchyi) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LAnchyi,1))); mask1 = .TRUE.
    OutData%LAnchyi = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LAnchyi))-1 ),mask1,OutData%LAnchyi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LAnchyi)
  ENDIF
  IF ( ALLOCATED(OutData%LAnchzi) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LAnchzi,1))); mask1 = .TRUE.
    OutData%LAnchzi = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LAnchzi))-1 ),mask1,OutData%LAnchzi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LAnchzi)
  ENDIF
  IF ( ALLOCATED(OutData%LFairxt) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LFairxt,1))); mask1 = .TRUE.
    OutData%LFairxt = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LFairxt))-1 ),mask1,OutData%LFairxt)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LFairxt)
  ENDIF
  IF ( ALLOCATED(OutData%LFairyt) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LFairyt,1))); mask1 = .TRUE.
    OutData%LFairyt = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LFairyt))-1 ),mask1,OutData%LFairyt)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LFairyt)
  ENDIF
  IF ( ALLOCATED(OutData%LFairzt) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LFairzt,1))); mask1 = .TRUE.
    OutData%LFairzt = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LFairzt))-1 ),mask1,OutData%LFairzt)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LFairzt)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnPackInitOutput

 SUBROUTINE FEAM_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_continuousstatetype), INTENT(INOUT) :: SrcContStateData
   TYPE(FEAM_continuousstatetype), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcContStateData%GLU)) THEN
   i1_l = LBOUND(SrcContStateData%GLU,1)
   i1_u = UBOUND(SrcContStateData%GLU,1)
   i2_l = LBOUND(SrcContStateData%GLU,2)
   i2_u = UBOUND(SrcContStateData%GLU,2)
   IF (.NOT.ALLOCATED(DstContStateData%GLU)) THEN 
      ALLOCATE(DstContStateData%GLU(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyContState: Error allocating DstContStateData%GLU.'
         RETURN
      END IF
   END IF
   DstContStateData%GLU = SrcContStateData%GLU
ENDIF
IF (ALLOCATED(SrcContStateData%GLDU)) THEN
   i1_l = LBOUND(SrcContStateData%GLDU,1)
   i1_u = UBOUND(SrcContStateData%GLDU,1)
   i2_l = LBOUND(SrcContStateData%GLDU,2)
   i2_u = UBOUND(SrcContStateData%GLDU,2)
   IF (.NOT.ALLOCATED(DstContStateData%GLDU)) THEN 
      ALLOCATE(DstContStateData%GLDU(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyContState: Error allocating DstContStateData%GLDU.'
         RETURN
      END IF
   END IF
   DstContStateData%GLDU = SrcContStateData%GLDU
ENDIF
 END SUBROUTINE FEAM_CopyContState

 SUBROUTINE FEAM_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(FEAM_continuousstatetype), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ContStateData%GLU)) THEN
   DEALLOCATE(ContStateData%GLU)
ENDIF
IF (ALLOCATED(ContStateData%GLDU)) THEN
   DEALLOCATE(ContStateData%GLDU)
ENDIF
 END SUBROUTINE FEAM_DestroyContState

 SUBROUTINE FEAM_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_continuousstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%GLU )  ! GLU 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GLDU )  ! GLDU 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%GLU) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GLU))-1 ) =  PACK(InData%GLU ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GLU)
  ENDIF
  IF ( ALLOCATED(InData%GLDU) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GLDU))-1 ) =  PACK(InData%GLDU ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GLDU)
  ENDIF
 END SUBROUTINE FEAM_PackContState

 SUBROUTINE FEAM_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_continuousstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%GLU) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GLU,1),SIZE(OutData%GLU,2))); mask2 = .TRUE.
    OutData%GLU = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GLU))-1 ),mask2,OutData%GLU)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GLU)
  ENDIF
  IF ( ALLOCATED(OutData%GLDU) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GLDU,1),SIZE(OutData%GLDU,2))); mask2 = .TRUE.
    OutData%GLDU = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GLDU))-1 ),mask2,OutData%GLDU)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GLDU)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnPackContState

 SUBROUTINE FEAM_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_discretestatetype), INTENT(INOUT) :: SrcDiscStateData
   TYPE(FEAM_discretestatetype), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstDiscStateData%DummyDiscState = SrcDiscStateData%DummyDiscState
 END SUBROUTINE FEAM_CopyDiscState

 SUBROUTINE FEAM_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(FEAM_discretestatetype), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE FEAM_DestroyDiscState

 SUBROUTINE FEAM_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_discretestatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyDiscState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyDiscState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE FEAM_PackDiscState

 SUBROUTINE FEAM_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_discretestatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyDiscState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnPackDiscState

 SUBROUTINE FEAM_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_constraintstatetype), INTENT(INOUT) :: SrcConstrStateData
   TYPE(FEAM_constraintstatetype), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstConstrStateData%TSN = SrcConstrStateData%TSN
   DstConstrStateData%TZER = SrcConstrStateData%TZER
 END SUBROUTINE FEAM_CopyConstrState

 SUBROUTINE FEAM_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(FEAM_constraintstatetype), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE FEAM_DestroyConstrState

 SUBROUTINE FEAM_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_constraintstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%TSN )  ! TSN 
  Re_BufSz    = Re_BufSz    + SIZE( InData%TZER )  ! TZER 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TSN))-1 ) =  PACK(InData%TSN ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%TSN)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TZER))-1 ) =  PACK(InData%TZER ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%TZER)
 END SUBROUTINE FEAM_PackConstrState

 SUBROUTINE FEAM_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_constraintstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  ALLOCATE(mask1(SIZE(OutData%TSN,1))); mask1 = .TRUE.
  OutData%TSN = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TSN))-1 ),mask1,OutData%TSN)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%TSN)
  ALLOCATE(mask1(SIZE(OutData%TZER,1))); mask1 = .TRUE.
  OutData%TZER = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TZER))-1 ),mask1,OutData%TZER)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%TZER)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnPackConstrState

 SUBROUTINE FEAM_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_otherstatetype), INTENT(INOUT) :: SrcOtherStateData
   TYPE(FEAM_otherstatetype), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOtherStateData%GLU0)) THEN
   i1_l = LBOUND(SrcOtherStateData%GLU0,1)
   i1_u = UBOUND(SrcOtherStateData%GLU0,1)
   i2_l = LBOUND(SrcOtherStateData%GLU0,2)
   i2_u = UBOUND(SrcOtherStateData%GLU0,2)
   IF (.NOT.ALLOCATED(DstOtherStateData%GLU0)) THEN 
      ALLOCATE(DstOtherStateData%GLU0(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyOtherState: Error allocating DstOtherStateData%GLU0.'
         RETURN
      END IF
   END IF
   DstOtherStateData%GLU0 = SrcOtherStateData%GLU0
ENDIF
IF (ALLOCATED(SrcOtherStateData%GLDDU)) THEN
   i1_l = LBOUND(SrcOtherStateData%GLDDU,1)
   i1_u = UBOUND(SrcOtherStateData%GLDDU,1)
   i2_l = LBOUND(SrcOtherStateData%GLDDU,2)
   i2_u = UBOUND(SrcOtherStateData%GLDDU,2)
   IF (.NOT.ALLOCATED(DstOtherStateData%GLDDU)) THEN 
      ALLOCATE(DstOtherStateData%GLDDU(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyOtherState: Error allocating DstOtherStateData%GLDDU.'
         RETURN
      END IF
   END IF
   DstOtherStateData%GLDDU = SrcOtherStateData%GLDDU
ENDIF
IF (ALLOCATED(SrcOtherStateData%GLF)) THEN
   i1_l = LBOUND(SrcOtherStateData%GLF,1)
   i1_u = UBOUND(SrcOtherStateData%GLF,1)
   i2_l = LBOUND(SrcOtherStateData%GLF,2)
   i2_u = UBOUND(SrcOtherStateData%GLF,2)
   IF (.NOT.ALLOCATED(DstOtherStateData%GLF)) THEN 
      ALLOCATE(DstOtherStateData%GLF(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyOtherState: Error allocating DstOtherStateData%GLF.'
         RETURN
      END IF
   END IF
   DstOtherStateData%GLF = SrcOtherStateData%GLF
ENDIF
IF (ALLOCATED(SrcOtherStateData%GLK)) THEN
   i1_l = LBOUND(SrcOtherStateData%GLK,1)
   i1_u = UBOUND(SrcOtherStateData%GLK,1)
   i2_l = LBOUND(SrcOtherStateData%GLK,2)
   i2_u = UBOUND(SrcOtherStateData%GLK,2)
   i3_l = LBOUND(SrcOtherStateData%GLK,3)
   i3_u = UBOUND(SrcOtherStateData%GLK,3)
   IF (.NOT.ALLOCATED(DstOtherStateData%GLK)) THEN 
      ALLOCATE(DstOtherStateData%GLK(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyOtherState: Error allocating DstOtherStateData%GLK.'
         RETURN
      END IF
   END IF
   DstOtherStateData%GLK = SrcOtherStateData%GLK
ENDIF
IF (ALLOCATED(SrcOtherStateData%GLUZR)) THEN
   i1_l = LBOUND(SrcOtherStateData%GLUZR,1)
   i1_u = UBOUND(SrcOtherStateData%GLUZR,1)
   i2_l = LBOUND(SrcOtherStateData%GLUZR,2)
   i2_u = UBOUND(SrcOtherStateData%GLUZR,2)
   i3_l = LBOUND(SrcOtherStateData%GLUZR,3)
   i3_u = UBOUND(SrcOtherStateData%GLUZR,3)
   IF (.NOT.ALLOCATED(DstOtherStateData%GLUZR)) THEN 
      ALLOCATE(DstOtherStateData%GLUZR(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyOtherState: Error allocating DstOtherStateData%GLUZR.'
         RETURN
      END IF
   END IF
   DstOtherStateData%GLUZR = SrcOtherStateData%GLUZR
ENDIF
IF (ALLOCATED(SrcOtherStateData%GTZER)) THEN
   i1_l = LBOUND(SrcOtherStateData%GTZER,1)
   i1_u = UBOUND(SrcOtherStateData%GTZER,1)
   i2_l = LBOUND(SrcOtherStateData%GTZER,2)
   i2_u = UBOUND(SrcOtherStateData%GTZER,2)
   IF (.NOT.ALLOCATED(DstOtherStateData%GTZER)) THEN 
      ALLOCATE(DstOtherStateData%GTZER(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyOtherState: Error allocating DstOtherStateData%GTZER.'
         RETURN
      END IF
   END IF
   DstOtherStateData%GTZER = SrcOtherStateData%GTZER
ENDIF
IF (ALLOCATED(SrcOtherStateData%GFORC0)) THEN
   i1_l = LBOUND(SrcOtherStateData%GFORC0,1)
   i1_u = UBOUND(SrcOtherStateData%GFORC0,1)
   i2_l = LBOUND(SrcOtherStateData%GFORC0,2)
   i2_u = UBOUND(SrcOtherStateData%GFORC0,2)
   i3_l = LBOUND(SrcOtherStateData%GFORC0,3)
   i3_u = UBOUND(SrcOtherStateData%GFORC0,3)
   IF (.NOT.ALLOCATED(DstOtherStateData%GFORC0)) THEN 
      ALLOCATE(DstOtherStateData%GFORC0(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyOtherState: Error allocating DstOtherStateData%GFORC0.'
         RETURN
      END IF
   END IF
   DstOtherStateData%GFORC0 = SrcOtherStateData%GFORC0
ENDIF
IF (ALLOCATED(SrcOtherStateData%GMASS0)) THEN
   i1_l = LBOUND(SrcOtherStateData%GMASS0,1)
   i1_u = UBOUND(SrcOtherStateData%GMASS0,1)
   i2_l = LBOUND(SrcOtherStateData%GMASS0,2)
   i2_u = UBOUND(SrcOtherStateData%GMASS0,2)
   i3_l = LBOUND(SrcOtherStateData%GMASS0,3)
   i3_u = UBOUND(SrcOtherStateData%GMASS0,3)
   i4_l = LBOUND(SrcOtherStateData%GMASS0,4)
   i4_u = UBOUND(SrcOtherStateData%GMASS0,4)
   IF (.NOT.ALLOCATED(DstOtherStateData%GMASS0)) THEN 
      ALLOCATE(DstOtherStateData%GMASS0(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyOtherState: Error allocating DstOtherStateData%GMASS0.'
         RETURN
      END IF
   END IF
   DstOtherStateData%GMASS0 = SrcOtherStateData%GMASS0
ENDIF
IF (ALLOCATED(SrcOtherStateData%FAST_FP)) THEN
   i1_l = LBOUND(SrcOtherStateData%FAST_FP,1)
   i1_u = UBOUND(SrcOtherStateData%FAST_FP,1)
   i2_l = LBOUND(SrcOtherStateData%FAST_FP,2)
   i2_u = UBOUND(SrcOtherStateData%FAST_FP,2)
   IF (.NOT.ALLOCATED(DstOtherStateData%FAST_FP)) THEN 
      ALLOCATE(DstOtherStateData%FAST_FP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyOtherState: Error allocating DstOtherStateData%FAST_FP.'
         RETURN
      END IF
   END IF
   DstOtherStateData%FAST_FP = SrcOtherStateData%FAST_FP
ENDIF
IF (ALLOCATED(SrcOtherStateData%FAST_FPA)) THEN
   i1_l = LBOUND(SrcOtherStateData%FAST_FPA,1)
   i1_u = UBOUND(SrcOtherStateData%FAST_FPA,1)
   i2_l = LBOUND(SrcOtherStateData%FAST_FPA,2)
   i2_u = UBOUND(SrcOtherStateData%FAST_FPA,2)
   IF (.NOT.ALLOCATED(DstOtherStateData%FAST_FPA)) THEN 
      ALLOCATE(DstOtherStateData%FAST_FPA(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyOtherState: Error allocating DstOtherStateData%FAST_FPA.'
         RETURN
      END IF
   END IF
   DstOtherStateData%FAST_FPA = SrcOtherStateData%FAST_FPA
ENDIF
IF (ALLOCATED(SrcOtherStateData%FAIR_T)) THEN
   i1_l = LBOUND(SrcOtherStateData%FAIR_T,1)
   i1_u = UBOUND(SrcOtherStateData%FAIR_T,1)
   IF (.NOT.ALLOCATED(DstOtherStateData%FAIR_T)) THEN 
      ALLOCATE(DstOtherStateData%FAIR_T(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyOtherState: Error allocating DstOtherStateData%FAIR_T.'
         RETURN
      END IF
   END IF
   DstOtherStateData%FAIR_T = SrcOtherStateData%FAIR_T
ENDIF
IF (ALLOCATED(SrcOtherStateData%FAST_RP)) THEN
   i1_l = LBOUND(SrcOtherStateData%FAST_RP,1)
   i1_u = UBOUND(SrcOtherStateData%FAST_RP,1)
   i2_l = LBOUND(SrcOtherStateData%FAST_RP,2)
   i2_u = UBOUND(SrcOtherStateData%FAST_RP,2)
   IF (.NOT.ALLOCATED(DstOtherStateData%FAST_RP)) THEN 
      ALLOCATE(DstOtherStateData%FAST_RP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyOtherState: Error allocating DstOtherStateData%FAST_RP.'
         RETURN
      END IF
   END IF
   DstOtherStateData%FAST_RP = SrcOtherStateData%FAST_RP
ENDIF
IF (ALLOCATED(SrcOtherStateData%ANCH_T)) THEN
   i1_l = LBOUND(SrcOtherStateData%ANCH_T,1)
   i1_u = UBOUND(SrcOtherStateData%ANCH_T,1)
   IF (.NOT.ALLOCATED(DstOtherStateData%ANCH_T)) THEN 
      ALLOCATE(DstOtherStateData%ANCH_T(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyOtherState: Error allocating DstOtherStateData%ANCH_T.'
         RETURN
      END IF
   END IF
   DstOtherStateData%ANCH_T = SrcOtherStateData%ANCH_T
ENDIF
IF (ALLOCATED(SrcOtherStateData%FAIR_ANG)) THEN
   i1_l = LBOUND(SrcOtherStateData%FAIR_ANG,1)
   i1_u = UBOUND(SrcOtherStateData%FAIR_ANG,1)
   i2_l = LBOUND(SrcOtherStateData%FAIR_ANG,2)
   i2_u = UBOUND(SrcOtherStateData%FAIR_ANG,2)
   IF (.NOT.ALLOCATED(DstOtherStateData%FAIR_ANG)) THEN 
      ALLOCATE(DstOtherStateData%FAIR_ANG(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyOtherState: Error allocating DstOtherStateData%FAIR_ANG.'
         RETURN
      END IF
   END IF
   DstOtherStateData%FAIR_ANG = SrcOtherStateData%FAIR_ANG
ENDIF
IF (ALLOCATED(SrcOtherStateData%ANCH_ANG)) THEN
   i1_l = LBOUND(SrcOtherStateData%ANCH_ANG,1)
   i1_u = UBOUND(SrcOtherStateData%ANCH_ANG,1)
   i2_l = LBOUND(SrcOtherStateData%ANCH_ANG,2)
   i2_u = UBOUND(SrcOtherStateData%ANCH_ANG,2)
   IF (.NOT.ALLOCATED(DstOtherStateData%ANCH_ANG)) THEN 
      ALLOCATE(DstOtherStateData%ANCH_ANG(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyOtherState: Error allocating DstOtherStateData%ANCH_ANG.'
         RETURN
      END IF
   END IF
   DstOtherStateData%ANCH_ANG = SrcOtherStateData%ANCH_ANG
ENDIF
   DstOtherStateData%ESTIF = SrcOtherStateData%ESTIF
   DstOtherStateData%EMASS = SrcOtherStateData%EMASS
   DstOtherStateData%FORCE = SrcOtherStateData%FORCE
   DstOtherStateData%RSDF = SrcOtherStateData%RSDF
IF (ALLOCATED(SrcOtherStateData%F_Lines)) THEN
   i1_l = LBOUND(SrcOtherStateData%F_Lines,1)
   i1_u = UBOUND(SrcOtherStateData%F_Lines,1)
   i2_l = LBOUND(SrcOtherStateData%F_Lines,2)
   i2_u = UBOUND(SrcOtherStateData%F_Lines,2)
   IF (.NOT.ALLOCATED(DstOtherStateData%F_Lines)) THEN 
      ALLOCATE(DstOtherStateData%F_Lines(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyOtherState: Error allocating DstOtherStateData%F_Lines.'
         RETURN
      END IF
   END IF
   DstOtherStateData%F_Lines = SrcOtherStateData%F_Lines
ENDIF
   DstOtherStateData%U = SrcOtherStateData%U
   DstOtherStateData%U0 = SrcOtherStateData%U0
   DstOtherStateData%DU = SrcOtherStateData%DU
   DstOtherStateData%DDU = SrcOtherStateData%DDU
   DstOtherStateData%FORC0 = SrcOtherStateData%FORC0
   DstOtherStateData%EMAS0 = SrcOtherStateData%EMAS0
   DstOtherStateData%INCR = SrcOtherStateData%INCR
   DstOtherStateData%BottomTouch = SrcOtherStateData%BottomTouch
   DstOtherStateData%Iteration1 = SrcOtherStateData%Iteration1
   DstOtherStateData%Iteration2 = SrcOtherStateData%Iteration2
   DstOtherStateData%R = SrcOtherStateData%R
   DstOtherStateData%RP = SrcOtherStateData%RP
   DstOtherStateData%FP = SrcOtherStateData%FP
   DstOtherStateData%SLIN = SrcOtherStateData%SLIN
   DstOtherStateData%STIFR = SrcOtherStateData%STIFR
   DstOtherStateData%RHSR = SrcOtherStateData%RHSR
IF (ALLOCATED(SrcOtherStateData%Line_Coordinate)) THEN
   i1_l = LBOUND(SrcOtherStateData%Line_Coordinate,1)
   i1_u = UBOUND(SrcOtherStateData%Line_Coordinate,1)
   i2_l = LBOUND(SrcOtherStateData%Line_Coordinate,2)
   i2_u = UBOUND(SrcOtherStateData%Line_Coordinate,2)
   i3_l = LBOUND(SrcOtherStateData%Line_Coordinate,3)
   i3_u = UBOUND(SrcOtherStateData%Line_Coordinate,3)
   IF (.NOT.ALLOCATED(DstOtherStateData%Line_Coordinate)) THEN 
      ALLOCATE(DstOtherStateData%Line_Coordinate(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyOtherState: Error allocating DstOtherStateData%Line_Coordinate.'
         RETURN
      END IF
   END IF
   DstOtherStateData%Line_Coordinate = SrcOtherStateData%Line_Coordinate
ENDIF
IF (ALLOCATED(SrcOtherStateData%Line_Tangent)) THEN
   i1_l = LBOUND(SrcOtherStateData%Line_Tangent,1)
   i1_u = UBOUND(SrcOtherStateData%Line_Tangent,1)
   i2_l = LBOUND(SrcOtherStateData%Line_Tangent,2)
   i2_u = UBOUND(SrcOtherStateData%Line_Tangent,2)
   i3_l = LBOUND(SrcOtherStateData%Line_Tangent,3)
   i3_u = UBOUND(SrcOtherStateData%Line_Tangent,3)
   IF (.NOT.ALLOCATED(DstOtherStateData%Line_Tangent)) THEN 
      ALLOCATE(DstOtherStateData%Line_Tangent(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyOtherState: Error allocating DstOtherStateData%Line_Tangent.'
         RETURN
      END IF
   END IF
   DstOtherStateData%Line_Tangent = SrcOtherStateData%Line_Tangent
ENDIF
 END SUBROUTINE FEAM_CopyOtherState

 SUBROUTINE FEAM_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(FEAM_otherstatetype), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OtherStateData%GLU0)) THEN
   DEALLOCATE(OtherStateData%GLU0)
ENDIF
IF (ALLOCATED(OtherStateData%GLDDU)) THEN
   DEALLOCATE(OtherStateData%GLDDU)
ENDIF
IF (ALLOCATED(OtherStateData%GLF)) THEN
   DEALLOCATE(OtherStateData%GLF)
ENDIF
IF (ALLOCATED(OtherStateData%GLK)) THEN
   DEALLOCATE(OtherStateData%GLK)
ENDIF
IF (ALLOCATED(OtherStateData%GLUZR)) THEN
   DEALLOCATE(OtherStateData%GLUZR)
ENDIF
IF (ALLOCATED(OtherStateData%GTZER)) THEN
   DEALLOCATE(OtherStateData%GTZER)
ENDIF
IF (ALLOCATED(OtherStateData%GFORC0)) THEN
   DEALLOCATE(OtherStateData%GFORC0)
ENDIF
IF (ALLOCATED(OtherStateData%GMASS0)) THEN
   DEALLOCATE(OtherStateData%GMASS0)
ENDIF
IF (ALLOCATED(OtherStateData%FAST_FP)) THEN
   DEALLOCATE(OtherStateData%FAST_FP)
ENDIF
IF (ALLOCATED(OtherStateData%FAST_FPA)) THEN
   DEALLOCATE(OtherStateData%FAST_FPA)
ENDIF
IF (ALLOCATED(OtherStateData%FAIR_T)) THEN
   DEALLOCATE(OtherStateData%FAIR_T)
ENDIF
IF (ALLOCATED(OtherStateData%FAST_RP)) THEN
   DEALLOCATE(OtherStateData%FAST_RP)
ENDIF
IF (ALLOCATED(OtherStateData%ANCH_T)) THEN
   DEALLOCATE(OtherStateData%ANCH_T)
ENDIF
IF (ALLOCATED(OtherStateData%FAIR_ANG)) THEN
   DEALLOCATE(OtherStateData%FAIR_ANG)
ENDIF
IF (ALLOCATED(OtherStateData%ANCH_ANG)) THEN
   DEALLOCATE(OtherStateData%ANCH_ANG)
ENDIF
IF (ALLOCATED(OtherStateData%F_Lines)) THEN
   DEALLOCATE(OtherStateData%F_Lines)
ENDIF
IF (ALLOCATED(OtherStateData%Line_Coordinate)) THEN
   DEALLOCATE(OtherStateData%Line_Coordinate)
ENDIF
IF (ALLOCATED(OtherStateData%Line_Tangent)) THEN
   DEALLOCATE(OtherStateData%Line_Tangent)
ENDIF
 END SUBROUTINE FEAM_DestroyOtherState

 SUBROUTINE FEAM_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_otherstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%GLU0 )  ! GLU0 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GLDDU )  ! GLDDU 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GLF )  ! GLF 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GLK )  ! GLK 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GLUZR )  ! GLUZR 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GTZER )  ! GTZER 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GFORC0 )  ! GFORC0 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GMASS0 )  ! GMASS0 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FAST_FP )  ! FAST_FP 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FAST_FPA )  ! FAST_FPA 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FAIR_T )  ! FAIR_T 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FAST_RP )  ! FAST_RP 
  Re_BufSz    = Re_BufSz    + SIZE( InData%ANCH_T )  ! ANCH_T 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FAIR_ANG )  ! FAIR_ANG 
  Re_BufSz    = Re_BufSz    + SIZE( InData%ANCH_ANG )  ! ANCH_ANG 
  Re_BufSz    = Re_BufSz    + SIZE( InData%ESTIF )  ! ESTIF 
  Re_BufSz    = Re_BufSz    + SIZE( InData%EMASS )  ! EMASS 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FORCE )  ! FORCE 
  Re_BufSz    = Re_BufSz    + SIZE( InData%RSDF )  ! RSDF 
  Re_BufSz    = Re_BufSz    + SIZE( InData%F_Lines )  ! F_Lines 
  Re_BufSz    = Re_BufSz    + SIZE( InData%U )  ! U 
  Re_BufSz    = Re_BufSz    + SIZE( InData%U0 )  ! U0 
  Re_BufSz    = Re_BufSz    + SIZE( InData%DU )  ! DU 
  Re_BufSz    = Re_BufSz    + SIZE( InData%DDU )  ! DDU 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FORC0 )  ! FORC0 
  Re_BufSz    = Re_BufSz    + SIZE( InData%EMAS0 )  ! EMAS0 
  Int_BufSz  = Int_BufSz  + 1  ! INCR
  Re_BufSz    = Re_BufSz    + SIZE( InData%R )  ! R 
  Re_BufSz    = Re_BufSz    + SIZE( InData%RP )  ! RP 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FP )  ! FP 
  Re_BufSz    = Re_BufSz    + SIZE( InData%SLIN )  ! SLIN 
  Re_BufSz    = Re_BufSz    + SIZE( InData%STIFR )  ! STIFR 
  Re_BufSz    = Re_BufSz    + SIZE( InData%RHSR )  ! RHSR 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Line_Coordinate )  ! Line_Coordinate 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Line_Tangent )  ! Line_Tangent 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%GLU0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GLU0))-1 ) =  PACK(InData%GLU0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GLU0)
  ENDIF
  IF ( ALLOCATED(InData%GLDDU) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GLDDU))-1 ) =  PACK(InData%GLDDU ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GLDDU)
  ENDIF
  IF ( ALLOCATED(InData%GLF) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GLF))-1 ) =  PACK(InData%GLF ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GLF)
  ENDIF
  IF ( ALLOCATED(InData%GLK) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GLK))-1 ) =  PACK(InData%GLK ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GLK)
  ENDIF
  IF ( ALLOCATED(InData%GLUZR) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GLUZR))-1 ) =  PACK(InData%GLUZR ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GLUZR)
  ENDIF
  IF ( ALLOCATED(InData%GTZER) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GTZER))-1 ) =  PACK(InData%GTZER ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GTZER)
  ENDIF
  IF ( ALLOCATED(InData%GFORC0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GFORC0))-1 ) =  PACK(InData%GFORC0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GFORC0)
  ENDIF
  IF ( ALLOCATED(InData%GMASS0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GMASS0))-1 ) =  PACK(InData%GMASS0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GMASS0)
  ENDIF
  IF ( ALLOCATED(InData%FAST_FP) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FAST_FP))-1 ) =  PACK(InData%FAST_FP ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FAST_FP)
  ENDIF
  IF ( ALLOCATED(InData%FAST_FPA) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FAST_FPA))-1 ) =  PACK(InData%FAST_FPA ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FAST_FPA)
  ENDIF
  IF ( ALLOCATED(InData%FAIR_T) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FAIR_T))-1 ) =  PACK(InData%FAIR_T ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FAIR_T)
  ENDIF
  IF ( ALLOCATED(InData%FAST_RP) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FAST_RP))-1 ) =  PACK(InData%FAST_RP ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FAST_RP)
  ENDIF
  IF ( ALLOCATED(InData%ANCH_T) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ANCH_T))-1 ) =  PACK(InData%ANCH_T ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%ANCH_T)
  ENDIF
  IF ( ALLOCATED(InData%FAIR_ANG) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FAIR_ANG))-1 ) =  PACK(InData%FAIR_ANG ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FAIR_ANG)
  ENDIF
  IF ( ALLOCATED(InData%ANCH_ANG) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ANCH_ANG))-1 ) =  PACK(InData%ANCH_ANG ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%ANCH_ANG)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ESTIF))-1 ) =  PACK(InData%ESTIF ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%ESTIF)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%EMASS))-1 ) =  PACK(InData%EMASS ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%EMASS)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FORCE))-1 ) =  PACK(InData%FORCE ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%FORCE)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%RSDF))-1 ) =  PACK(InData%RSDF ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%RSDF)
  IF ( ALLOCATED(InData%F_Lines) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%F_Lines))-1 ) =  PACK(InData%F_Lines ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%F_Lines)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%U))-1 ) =  PACK(InData%U ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%U)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%U0))-1 ) =  PACK(InData%U0 ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%U0)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DU))-1 ) =  PACK(InData%DU ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%DU)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DDU))-1 ) =  PACK(InData%DDU ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%DDU)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FORC0))-1 ) =  PACK(InData%FORC0 ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%FORC0)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%EMAS0))-1 ) =  PACK(InData%EMAS0 ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%EMAS0)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%INCR )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%R))-1 ) =  PACK(InData%R ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%R)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%RP))-1 ) =  PACK(InData%RP ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%RP)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FP))-1 ) =  PACK(InData%FP ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%FP)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SLIN))-1 ) =  PACK(InData%SLIN ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%SLIN)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%STIFR))-1 ) =  PACK(InData%STIFR ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%STIFR)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%RHSR))-1 ) =  PACK(InData%RHSR ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%RHSR)
  IF ( ALLOCATED(InData%Line_Coordinate) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Line_Coordinate))-1 ) =  PACK(InData%Line_Coordinate ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Line_Coordinate)
  ENDIF
  IF ( ALLOCATED(InData%Line_Tangent) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Line_Tangent))-1 ) =  PACK(InData%Line_Tangent ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Line_Tangent)
  ENDIF
 END SUBROUTINE FEAM_PackOtherState

 SUBROUTINE FEAM_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_otherstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%GLU0) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GLU0,1),SIZE(OutData%GLU0,2))); mask2 = .TRUE.
    OutData%GLU0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GLU0))-1 ),mask2,OutData%GLU0)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GLU0)
  ENDIF
  IF ( ALLOCATED(OutData%GLDDU) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GLDDU,1),SIZE(OutData%GLDDU,2))); mask2 = .TRUE.
    OutData%GLDDU = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GLDDU))-1 ),mask2,OutData%GLDDU)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GLDDU)
  ENDIF
  IF ( ALLOCATED(OutData%GLF) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GLF,1),SIZE(OutData%GLF,2))); mask2 = .TRUE.
    OutData%GLF = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GLF))-1 ),mask2,OutData%GLF)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GLF)
  ENDIF
  IF ( ALLOCATED(OutData%GLK) ) THEN
  ALLOCATE(mask3(SIZE(OutData%GLK,1),SIZE(OutData%GLK,2),SIZE(OutData%GLK,3))); mask3 = .TRUE.
    OutData%GLK = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GLK))-1 ),mask3,OutData%GLK)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GLK)
  ENDIF
  IF ( ALLOCATED(OutData%GLUZR) ) THEN
  ALLOCATE(mask3(SIZE(OutData%GLUZR,1),SIZE(OutData%GLUZR,2),SIZE(OutData%GLUZR,3))); mask3 = .TRUE.
    OutData%GLUZR = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GLUZR))-1 ),mask3,OutData%GLUZR)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GLUZR)
  ENDIF
  IF ( ALLOCATED(OutData%GTZER) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GTZER,1),SIZE(OutData%GTZER,2))); mask2 = .TRUE.
    OutData%GTZER = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GTZER))-1 ),mask2,OutData%GTZER)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GTZER)
  ENDIF
  IF ( ALLOCATED(OutData%GFORC0) ) THEN
  ALLOCATE(mask3(SIZE(OutData%GFORC0,1),SIZE(OutData%GFORC0,2),SIZE(OutData%GFORC0,3))); mask3 = .TRUE.
    OutData%GFORC0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GFORC0))-1 ),mask3,OutData%GFORC0)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GFORC0)
  ENDIF
  IF ( ALLOCATED(OutData%GMASS0) ) THEN
  ALLOCATE(mask4(SIZE(OutData%GMASS0,1),SIZE(OutData%GMASS0,2),SIZE(OutData%GMASS0,3),SIZE(OutData%GMASS0,4))); mask4 = .TRUE.
    OutData%GMASS0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GMASS0))-1 ),mask4,OutData%GMASS0)
  DEALLOCATE(mask4)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GMASS0)
  ENDIF
  IF ( ALLOCATED(OutData%FAST_FP) ) THEN
  ALLOCATE(mask2(SIZE(OutData%FAST_FP,1),SIZE(OutData%FAST_FP,2))); mask2 = .TRUE.
    OutData%FAST_FP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FAST_FP))-1 ),mask2,OutData%FAST_FP)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FAST_FP)
  ENDIF
  IF ( ALLOCATED(OutData%FAST_FPA) ) THEN
  ALLOCATE(mask2(SIZE(OutData%FAST_FPA,1),SIZE(OutData%FAST_FPA,2))); mask2 = .TRUE.
    OutData%FAST_FPA = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FAST_FPA))-1 ),mask2,OutData%FAST_FPA)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FAST_FPA)
  ENDIF
  IF ( ALLOCATED(OutData%FAIR_T) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FAIR_T,1))); mask1 = .TRUE.
    OutData%FAIR_T = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FAIR_T))-1 ),mask1,OutData%FAIR_T)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FAIR_T)
  ENDIF
  IF ( ALLOCATED(OutData%FAST_RP) ) THEN
  ALLOCATE(mask2(SIZE(OutData%FAST_RP,1),SIZE(OutData%FAST_RP,2))); mask2 = .TRUE.
    OutData%FAST_RP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FAST_RP))-1 ),mask2,OutData%FAST_RP)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FAST_RP)
  ENDIF
  IF ( ALLOCATED(OutData%ANCH_T) ) THEN
  ALLOCATE(mask1(SIZE(OutData%ANCH_T,1))); mask1 = .TRUE.
    OutData%ANCH_T = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ANCH_T))-1 ),mask1,OutData%ANCH_T)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%ANCH_T)
  ENDIF
  IF ( ALLOCATED(OutData%FAIR_ANG) ) THEN
  ALLOCATE(mask2(SIZE(OutData%FAIR_ANG,1),SIZE(OutData%FAIR_ANG,2))); mask2 = .TRUE.
    OutData%FAIR_ANG = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FAIR_ANG))-1 ),mask2,OutData%FAIR_ANG)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FAIR_ANG)
  ENDIF
  IF ( ALLOCATED(OutData%ANCH_ANG) ) THEN
  ALLOCATE(mask2(SIZE(OutData%ANCH_ANG,1),SIZE(OutData%ANCH_ANG,2))); mask2 = .TRUE.
    OutData%ANCH_ANG = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ANCH_ANG))-1 ),mask2,OutData%ANCH_ANG)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%ANCH_ANG)
  ENDIF
  ALLOCATE(mask2(SIZE(OutData%ESTIF,1),SIZE(OutData%ESTIF,2))); mask2 = .TRUE.
  OutData%ESTIF = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ESTIF))-1 ),mask2,OutData%ESTIF)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%ESTIF)
  ALLOCATE(mask2(SIZE(OutData%EMASS,1),SIZE(OutData%EMASS,2))); mask2 = .TRUE.
  OutData%EMASS = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%EMASS))-1 ),mask2,OutData%EMASS)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%EMASS)
  ALLOCATE(mask1(SIZE(OutData%FORCE,1))); mask1 = .TRUE.
  OutData%FORCE = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FORCE))-1 ),mask1,OutData%FORCE)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%FORCE)
  ALLOCATE(mask1(SIZE(OutData%RSDF,1))); mask1 = .TRUE.
  OutData%RSDF = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%RSDF))-1 ),mask1,OutData%RSDF)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%RSDF)
  IF ( ALLOCATED(OutData%F_Lines) ) THEN
  ALLOCATE(mask2(SIZE(OutData%F_Lines,1),SIZE(OutData%F_Lines,2))); mask2 = .TRUE.
    OutData%F_Lines = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%F_Lines))-1 ),mask2,OutData%F_Lines)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%F_Lines)
  ENDIF
  ALLOCATE(mask2(SIZE(OutData%U,1),SIZE(OutData%U,2))); mask2 = .TRUE.
  OutData%U = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%U))-1 ),mask2,OutData%U)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%U)
  ALLOCATE(mask2(SIZE(OutData%U0,1),SIZE(OutData%U0,2))); mask2 = .TRUE.
  OutData%U0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%U0))-1 ),mask2,OutData%U0)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%U0)
  ALLOCATE(mask2(SIZE(OutData%DU,1),SIZE(OutData%DU,2))); mask2 = .TRUE.
  OutData%DU = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DU))-1 ),mask2,OutData%DU)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%DU)
  ALLOCATE(mask2(SIZE(OutData%DDU,1),SIZE(OutData%DDU,2))); mask2 = .TRUE.
  OutData%DDU = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DDU))-1 ),mask2,OutData%DDU)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%DDU)
  ALLOCATE(mask1(SIZE(OutData%FORC0,1))); mask1 = .TRUE.
  OutData%FORC0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FORC0))-1 ),mask1,OutData%FORC0)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%FORC0)
  ALLOCATE(mask2(SIZE(OutData%EMAS0,1),SIZE(OutData%EMAS0,2))); mask2 = .TRUE.
  OutData%EMAS0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%EMAS0))-1 ),mask2,OutData%EMAS0)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%EMAS0)
  OutData%INCR = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%R,1))); mask1 = .TRUE.
  OutData%R = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%R))-1 ),mask1,OutData%R)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%R)
  ALLOCATE(mask1(SIZE(OutData%RP,1))); mask1 = .TRUE.
  OutData%RP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%RP))-1 ),mask1,OutData%RP)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%RP)
  ALLOCATE(mask1(SIZE(OutData%FP,1))); mask1 = .TRUE.
  OutData%FP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FP))-1 ),mask1,OutData%FP)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%FP)
  ALLOCATE(mask1(SIZE(OutData%SLIN,1))); mask1 = .TRUE.
  OutData%SLIN = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SLIN))-1 ),mask1,OutData%SLIN)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%SLIN)
  ALLOCATE(mask2(SIZE(OutData%STIFR,1),SIZE(OutData%STIFR,2))); mask2 = .TRUE.
  OutData%STIFR = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%STIFR))-1 ),mask2,OutData%STIFR)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%STIFR)
  ALLOCATE(mask1(SIZE(OutData%RHSR,1))); mask1 = .TRUE.
  OutData%RHSR = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%RHSR))-1 ),mask1,OutData%RHSR)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%RHSR)
  IF ( ALLOCATED(OutData%Line_Coordinate) ) THEN
  ALLOCATE(mask3(SIZE(OutData%Line_Coordinate,1),SIZE(OutData%Line_Coordinate,2),SIZE(OutData%Line_Coordinate,3))); mask3 = .TRUE.
    OutData%Line_Coordinate = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Line_Coordinate))-1 ),mask3,OutData%Line_Coordinate)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Line_Coordinate)
  ENDIF
  IF ( ALLOCATED(OutData%Line_Tangent) ) THEN
  ALLOCATE(mask3(SIZE(OutData%Line_Tangent,1),SIZE(OutData%Line_Tangent,2),SIZE(OutData%Line_Tangent,3))); mask3 = .TRUE.
    OutData%Line_Tangent = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Line_Tangent))-1 ),mask3,OutData%Line_Tangent)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Line_Tangent)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnPackOtherState

 SUBROUTINE FEAM_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_parametertype), INTENT(INOUT) :: SrcParamData
   TYPE(FEAM_parametertype), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstParamData%DT = SrcParamData%DT
   DstParamData%GRAV = SrcParamData%GRAV
   DstParamData%Eps = SrcParamData%Eps
   DstParamData%Gravity = SrcParamData%Gravity
   DstParamData%WtrDens = SrcParamData%WtrDens
   DstParamData%MaxIter = SrcParamData%MaxIter
   DstParamData%NHBD = SrcParamData%NHBD
   DstParamData%NDIM = SrcParamData%NDIM
IF (ALLOCATED(SrcParamData%NEQ)) THEN
   i1_l = LBOUND(SrcParamData%NEQ,1)
   i1_u = UBOUND(SrcParamData%NEQ,1)
   IF (.NOT.ALLOCATED(DstParamData%NEQ)) THEN 
      ALLOCATE(DstParamData%NEQ(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyParam: Error allocating DstParamData%NEQ.'
         RETURN
      END IF
   END IF
   DstParamData%NEQ = SrcParamData%NEQ
ENDIF
   DstParamData%NBAND = SrcParamData%NBAND
   DstParamData%DYN = SrcParamData%DYN
   DstParamData%NumLines = SrcParamData%NumLines
   DstParamData%NumElems = SrcParamData%NumElems
IF (ALLOCATED(SrcParamData%GSL)) THEN
   i1_l = LBOUND(SrcParamData%GSL,1)
   i1_u = UBOUND(SrcParamData%GSL,1)
   i2_l = LBOUND(SrcParamData%GSL,2)
   i2_u = UBOUND(SrcParamData%GSL,2)
   i3_l = LBOUND(SrcParamData%GSL,3)
   i3_u = UBOUND(SrcParamData%GSL,3)
   IF (.NOT.ALLOCATED(DstParamData%GSL)) THEN 
      ALLOCATE(DstParamData%GSL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyParam: Error allocating DstParamData%GSL.'
         RETURN
      END IF
   END IF
   DstParamData%GSL = SrcParamData%GSL
ENDIF
IF (ALLOCATED(SrcParamData%GP)) THEN
   i1_l = LBOUND(SrcParamData%GP,1)
   i1_u = UBOUND(SrcParamData%GP,1)
   i2_l = LBOUND(SrcParamData%GP,2)
   i2_u = UBOUND(SrcParamData%GP,2)
   IF (.NOT.ALLOCATED(DstParamData%GP)) THEN 
      ALLOCATE(DstParamData%GP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyParam: Error allocating DstParamData%GP.'
         RETURN
      END IF
   END IF
   DstParamData%GP = SrcParamData%GP
ENDIF
IF (ALLOCATED(SrcParamData%Elength)) THEN
   i1_l = LBOUND(SrcParamData%Elength,1)
   i1_u = UBOUND(SrcParamData%Elength,1)
   IF (.NOT.ALLOCATED(DstParamData%Elength)) THEN 
      ALLOCATE(DstParamData%Elength(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyParam: Error allocating DstParamData%Elength.'
         RETURN
      END IF
   END IF
   DstParamData%Elength = SrcParamData%Elength
ENDIF
IF (ALLOCATED(SrcParamData%BottmElev)) THEN
   i1_l = LBOUND(SrcParamData%BottmElev,1)
   i1_u = UBOUND(SrcParamData%BottmElev,1)
   IF (.NOT.ALLOCATED(DstParamData%BottmElev)) THEN 
      ALLOCATE(DstParamData%BottmElev(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyParam: Error allocating DstParamData%BottmElev.'
         RETURN
      END IF
   END IF
   DstParamData%BottmElev = SrcParamData%BottmElev
ENDIF
IF (ALLOCATED(SrcParamData%BottmStiff)) THEN
   i1_l = LBOUND(SrcParamData%BottmStiff,1)
   i1_u = UBOUND(SrcParamData%BottmStiff,1)
   IF (.NOT.ALLOCATED(DstParamData%BottmStiff)) THEN 
      ALLOCATE(DstParamData%BottmStiff(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyParam: Error allocating DstParamData%BottmStiff.'
         RETURN
      END IF
   END IF
   DstParamData%BottmStiff = SrcParamData%BottmStiff
ENDIF
IF (ALLOCATED(SrcParamData%LMassDen)) THEN
   i1_l = LBOUND(SrcParamData%LMassDen,1)
   i1_u = UBOUND(SrcParamData%LMassDen,1)
   IF (.NOT.ALLOCATED(DstParamData%LMassDen)) THEN 
      ALLOCATE(DstParamData%LMassDen(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyParam: Error allocating DstParamData%LMassDen.'
         RETURN
      END IF
   END IF
   DstParamData%LMassDen = SrcParamData%LMassDen
ENDIF
IF (ALLOCATED(SrcParamData%LDMassDen)) THEN
   i1_l = LBOUND(SrcParamData%LDMassDen,1)
   i1_u = UBOUND(SrcParamData%LDMassDen,1)
   IF (.NOT.ALLOCATED(DstParamData%LDMassDen)) THEN 
      ALLOCATE(DstParamData%LDMassDen(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyParam: Error allocating DstParamData%LDMassDen.'
         RETURN
      END IF
   END IF
   DstParamData%LDMassDen = SrcParamData%LDMassDen
ENDIF
IF (ALLOCATED(SrcParamData%LEAStiff)) THEN
   i1_l = LBOUND(SrcParamData%LEAStiff,1)
   i1_u = UBOUND(SrcParamData%LEAStiff,1)
   IF (.NOT.ALLOCATED(DstParamData%LEAStiff)) THEN 
      ALLOCATE(DstParamData%LEAStiff(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyParam: Error allocating DstParamData%LEAStiff.'
         RETURN
      END IF
   END IF
   DstParamData%LEAStiff = SrcParamData%LEAStiff
ENDIF
IF (ALLOCATED(SrcParamData%Bvp)) THEN
   i1_l = LBOUND(SrcParamData%Bvp,1)
   i1_u = UBOUND(SrcParamData%Bvp,1)
   i2_l = LBOUND(SrcParamData%Bvp,2)
   i2_u = UBOUND(SrcParamData%Bvp,2)
   IF (.NOT.ALLOCATED(DstParamData%Bvp)) THEN 
      ALLOCATE(DstParamData%Bvp(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyParam: Error allocating DstParamData%Bvp.'
         RETURN
      END IF
   END IF
   DstParamData%Bvp = SrcParamData%Bvp
ENDIF
   DstParamData%SHAP = SrcParamData%SHAP
   DstParamData%SHAPS = SrcParamData%SHAPS
   DstParamData%GAUSSW = SrcParamData%GAUSSW
   DstParamData%NGAUSS = SrcParamData%NGAUSS
   DstParamData%SHAPT = SrcParamData%SHAPT
   DstParamData%SHAPTS = SrcParamData%SHAPTS
   DstParamData%NTRAP = SrcParamData%NTRAP
   DstParamData%SBEND = SrcParamData%SBEND
   DstParamData%STEN = SrcParamData%STEN
   DstParamData%RMASS = SrcParamData%RMASS
   DstParamData%RADDM = SrcParamData%RADDM
   DstParamData%PMPN = SrcParamData%PMPN
   DstParamData%AM = SrcParamData%AM
   DstParamData%PM = SrcParamData%PM
   DstParamData%IDOF = SrcParamData%IDOF
   DstParamData%JDOF = SrcParamData%JDOF
   DstParamData%PPA = SrcParamData%PPA
   DstParamData%PtfmRefzt = SrcParamData%PtfmRefzt
   DstParamData%NumOuts = SrcParamData%NumOuts
   DstParamData%RootName = SrcParamData%RootName
IF (ALLOCATED(SrcParamData%OutParam)) THEN
   i1_l = LBOUND(SrcParamData%OutParam,1)
   i1_u = UBOUND(SrcParamData%OutParam,1)
   IF (.NOT.ALLOCATED(DstParamData%OutParam)) THEN 
      ALLOCATE(DstParamData%OutParam(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyParam: Error allocating DstParamData%OutParam.'
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%OutParam,1), UBOUND(SrcParamData%OutParam,1)
      CALL NWTC_Library_Copyoutparmtype( SrcParamData%OutParam(i1), DstParamData%OutParam(i1), CtrlCode, ErrStat, ErrMsg )
   ENDDO
ENDIF
   DstParamData%Delim = SrcParamData%Delim
 END SUBROUTINE FEAM_CopyParam

 SUBROUTINE FEAM_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(FEAM_parametertype), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%NEQ)) THEN
   DEALLOCATE(ParamData%NEQ)
ENDIF
IF (ALLOCATED(ParamData%GSL)) THEN
   DEALLOCATE(ParamData%GSL)
ENDIF
IF (ALLOCATED(ParamData%GP)) THEN
   DEALLOCATE(ParamData%GP)
ENDIF
IF (ALLOCATED(ParamData%Elength)) THEN
   DEALLOCATE(ParamData%Elength)
ENDIF
IF (ALLOCATED(ParamData%BottmElev)) THEN
   DEALLOCATE(ParamData%BottmElev)
ENDIF
IF (ALLOCATED(ParamData%BottmStiff)) THEN
   DEALLOCATE(ParamData%BottmStiff)
ENDIF
IF (ALLOCATED(ParamData%LMassDen)) THEN
   DEALLOCATE(ParamData%LMassDen)
ENDIF
IF (ALLOCATED(ParamData%LDMassDen)) THEN
   DEALLOCATE(ParamData%LDMassDen)
ENDIF
IF (ALLOCATED(ParamData%LEAStiff)) THEN
   DEALLOCATE(ParamData%LEAStiff)
ENDIF
IF (ALLOCATED(ParamData%Bvp)) THEN
   DEALLOCATE(ParamData%Bvp)
ENDIF
IF (ALLOCATED(ParamData%OutParam)) THEN
DO i1 = LBOUND(ParamData%OutParam,1), UBOUND(ParamData%OutParam,1)
  CALL NWTC_Library_Destroyoutparmtype( ParamData%OutParam(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%OutParam)
ENDIF
 END SUBROUTINE FEAM_DestroyParam

 SUBROUTINE FEAM_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_parametertype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_OutParam_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_OutParam_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_OutParam_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! DT
  Re_BufSz    = Re_BufSz    + SIZE( InData%GRAV )  ! GRAV 
  Re_BufSz   = Re_BufSz   + 1  ! Eps
  Re_BufSz   = Re_BufSz   + 1  ! Gravity
  Re_BufSz   = Re_BufSz   + 1  ! WtrDens
  Int_BufSz  = Int_BufSz  + 1  ! MaxIter
  Int_BufSz  = Int_BufSz  + 1  ! NHBD
  Int_BufSz  = Int_BufSz  + 1  ! NDIM
  Int_BufSz   = Int_BufSz   + SIZE( InData%NEQ )  ! NEQ 
  Int_BufSz  = Int_BufSz  + 1  ! NBAND
  Int_BufSz  = Int_BufSz  + 1  ! NumLines
  Int_BufSz  = Int_BufSz  + 1  ! NumElems
  Re_BufSz    = Re_BufSz    + SIZE( InData%GSL )  ! GSL 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GP )  ! GP 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Elength )  ! Elength 
  Re_BufSz    = Re_BufSz    + SIZE( InData%BottmElev )  ! BottmElev 
  Re_BufSz    = Re_BufSz    + SIZE( InData%BottmStiff )  ! BottmStiff 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LMassDen )  ! LMassDen 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LDMassDen )  ! LDMassDen 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LEAStiff )  ! LEAStiff 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Bvp )  ! Bvp 
  Re_BufSz    = Re_BufSz    + SIZE( InData%SHAP )  ! SHAP 
  Re_BufSz    = Re_BufSz    + SIZE( InData%SHAPS )  ! SHAPS 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GAUSSW )  ! GAUSSW 
  Int_BufSz  = Int_BufSz  + 1  ! NGAUSS
  Re_BufSz    = Re_BufSz    + SIZE( InData%SHAPT )  ! SHAPT 
  Re_BufSz    = Re_BufSz    + SIZE( InData%SHAPTS )  ! SHAPTS 
  Re_BufSz   = Re_BufSz   + 1  ! NTRAP
  Re_BufSz    = Re_BufSz    + SIZE( InData%SBEND )  ! SBEND 
  Re_BufSz    = Re_BufSz    + SIZE( InData%STEN )  ! STEN 
  Re_BufSz    = Re_BufSz    + SIZE( InData%RMASS )  ! RMASS 
  Re_BufSz    = Re_BufSz    + SIZE( InData%RADDM )  ! RADDM 
  Re_BufSz    = Re_BufSz    + SIZE( InData%PMPN )  ! PMPN 
  Re_BufSz    = Re_BufSz    + SIZE( InData%AM )  ! AM 
  Re_BufSz    = Re_BufSz    + SIZE( InData%PM )  ! PM 
  Int_BufSz   = Int_BufSz   + SIZE( InData%IDOF )  ! IDOF 
  Int_BufSz   = Int_BufSz   + SIZE( InData%JDOF )  ! JDOF 
  Re_BufSz    = Re_BufSz    + SIZE( InData%PPA )  ! PPA 
  Re_BufSz   = Re_BufSz   + 1  ! PtfmRefzt
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
  CALL NWTC_Library_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, InData%OutParam(i1), ErrStat, ErrMsg, .TRUE. ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_OutParam_Buf  ) ! OutParam
  IF(ALLOCATED(Db_OutParam_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_OutParam_Buf  ) ! OutParam
  IF(ALLOCATED(Int_OutParam_Buf))Int_BufSz = Int_BufSz + SIZE( Int_OutParam_Buf ) ! OutParam
  IF(ALLOCATED(Re_OutParam_Buf))  DEALLOCATE(Re_OutParam_Buf)
  IF(ALLOCATED(Db_OutParam_Buf))  DEALLOCATE(Db_OutParam_Buf)
  IF(ALLOCATED(Int_OutParam_Buf)) DEALLOCATE(Int_OutParam_Buf)
ENDDO
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%DT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GRAV))-1 ) =  PACK(InData%GRAV ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%GRAV)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Eps )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Gravity )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WtrDens )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MaxIter )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NHBD )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NDIM )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%NEQ) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NEQ))-1 ) = PACK(InData%NEQ ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%NEQ)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NBAND )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumLines )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumElems )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%GSL) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GSL))-1 ) =  PACK(InData%GSL ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GSL)
  ENDIF
  IF ( ALLOCATED(InData%GP) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GP))-1 ) =  PACK(InData%GP ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GP)
  ENDIF
  IF ( ALLOCATED(InData%Elength) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Elength))-1 ) =  PACK(InData%Elength ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Elength)
  ENDIF
  IF ( ALLOCATED(InData%BottmElev) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%BottmElev))-1 ) =  PACK(InData%BottmElev ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%BottmElev)
  ENDIF
  IF ( ALLOCATED(InData%BottmStiff) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%BottmStiff))-1 ) =  PACK(InData%BottmStiff ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%BottmStiff)
  ENDIF
  IF ( ALLOCATED(InData%LMassDen) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LMassDen))-1 ) =  PACK(InData%LMassDen ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LMassDen)
  ENDIF
  IF ( ALLOCATED(InData%LDMassDen) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LDMassDen))-1 ) =  PACK(InData%LDMassDen ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LDMassDen)
  ENDIF
  IF ( ALLOCATED(InData%LEAStiff) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LEAStiff))-1 ) =  PACK(InData%LEAStiff ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LEAStiff)
  ENDIF
  IF ( ALLOCATED(InData%Bvp) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Bvp))-1 ) =  PACK(InData%Bvp ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Bvp)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SHAP))-1 ) =  PACK(InData%SHAP ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%SHAP)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SHAPS))-1 ) =  PACK(InData%SHAPS ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%SHAPS)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GAUSSW))-1 ) =  PACK(InData%GAUSSW ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%GAUSSW)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NGAUSS )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SHAPT))-1 ) =  PACK(InData%SHAPT ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%SHAPT)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SHAPTS))-1 ) =  PACK(InData%SHAPTS ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%SHAPTS)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%NTRAP )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SBEND))-1 ) =  PACK(InData%SBEND ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%SBEND)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%STEN))-1 ) =  PACK(InData%STEN ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%STEN)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%RMASS))-1 ) =  PACK(InData%RMASS ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%RMASS)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%RADDM))-1 ) =  PACK(InData%RADDM ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%RADDM)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PMPN))-1 ) =  PACK(InData%PMPN ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%PMPN)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%AM))-1 ) =  PACK(InData%AM ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%AM)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PM))-1 ) =  PACK(InData%PM ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%PM)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDOF))-1 ) = PACK(InData%IDOF ,.TRUE.)
  Int_Xferred   = Int_Xferred   + SIZE(InData%IDOF)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%JDOF))-1 ) = PACK(InData%JDOF ,.TRUE.)
  Int_Xferred   = Int_Xferred   + SIZE(InData%JDOF)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PPA))-1 ) =  PACK(InData%PPA ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%PPA)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%PtfmRefzt )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
  CALL NWTC_Library_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, InData%OutParam(i1), ErrStat, ErrMsg, OnlySize ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_OutParam_Buf)-1 ) = Re_OutParam_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Db_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_OutParam_Buf)-1 ) = Db_OutParam_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Int_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_OutParam_Buf)-1 ) = Int_OutParam_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_OutParam_Buf)
  ENDIF
  IF( ALLOCATED(Re_OutParam_Buf) )  DEALLOCATE(Re_OutParam_Buf)
  IF( ALLOCATED(Db_OutParam_Buf) )  DEALLOCATE(Db_OutParam_Buf)
  IF( ALLOCATED(Int_OutParam_Buf) ) DEALLOCATE(Int_OutParam_Buf)
ENDDO
 END SUBROUTINE FEAM_PackParam

 SUBROUTINE FEAM_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_parametertype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_OutParam_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_OutParam_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_OutParam_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%GRAV,1))); mask1 = .TRUE.
  OutData%GRAV = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GRAV))-1 ),mask1,OutData%GRAV)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%GRAV)
  OutData%Eps = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Gravity = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WtrDens = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MaxIter = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NHBD = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NDIM = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%NEQ) ) THEN
  ALLOCATE(mask1(SIZE(OutData%NEQ,1))); mask1 = .TRUE.
    OutData%NEQ = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%NEQ))-1 ),mask1,OutData%NEQ)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%NEQ)
  ENDIF
  OutData%NBAND = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumLines = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumElems = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%GSL) ) THEN
  ALLOCATE(mask3(SIZE(OutData%GSL,1),SIZE(OutData%GSL,2),SIZE(OutData%GSL,3))); mask3 = .TRUE.
    OutData%GSL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GSL))-1 ),mask3,OutData%GSL)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GSL)
  ENDIF
  IF ( ALLOCATED(OutData%GP) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GP,1),SIZE(OutData%GP,2))); mask2 = .TRUE.
    OutData%GP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GP))-1 ),mask2,OutData%GP)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GP)
  ENDIF
  IF ( ALLOCATED(OutData%Elength) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Elength,1))); mask1 = .TRUE.
    OutData%Elength = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Elength))-1 ),mask1,OutData%Elength)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Elength)
  ENDIF
  IF ( ALLOCATED(OutData%BottmElev) ) THEN
  ALLOCATE(mask1(SIZE(OutData%BottmElev,1))); mask1 = .TRUE.
    OutData%BottmElev = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%BottmElev))-1 ),mask1,OutData%BottmElev)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%BottmElev)
  ENDIF
  IF ( ALLOCATED(OutData%BottmStiff) ) THEN
  ALLOCATE(mask1(SIZE(OutData%BottmStiff,1))); mask1 = .TRUE.
    OutData%BottmStiff = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%BottmStiff))-1 ),mask1,OutData%BottmStiff)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%BottmStiff)
  ENDIF
  IF ( ALLOCATED(OutData%LMassDen) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LMassDen,1))); mask1 = .TRUE.
    OutData%LMassDen = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LMassDen))-1 ),mask1,OutData%LMassDen)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LMassDen)
  ENDIF
  IF ( ALLOCATED(OutData%LDMassDen) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LDMassDen,1))); mask1 = .TRUE.
    OutData%LDMassDen = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LDMassDen))-1 ),mask1,OutData%LDMassDen)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LDMassDen)
  ENDIF
  IF ( ALLOCATED(OutData%LEAStiff) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LEAStiff,1))); mask1 = .TRUE.
    OutData%LEAStiff = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LEAStiff))-1 ),mask1,OutData%LEAStiff)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LEAStiff)
  ENDIF
  IF ( ALLOCATED(OutData%Bvp) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Bvp,1),SIZE(OutData%Bvp,2))); mask2 = .TRUE.
    OutData%Bvp = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Bvp))-1 ),mask2,OutData%Bvp)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Bvp)
  ENDIF
  ALLOCATE(mask2(SIZE(OutData%SHAP,1),SIZE(OutData%SHAP,2))); mask2 = .TRUE.
  OutData%SHAP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SHAP))-1 ),mask2,OutData%SHAP)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%SHAP)
  ALLOCATE(mask2(SIZE(OutData%SHAPS,1),SIZE(OutData%SHAPS,2))); mask2 = .TRUE.
  OutData%SHAPS = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SHAPS))-1 ),mask2,OutData%SHAPS)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%SHAPS)
  ALLOCATE(mask1(SIZE(OutData%GAUSSW,1))); mask1 = .TRUE.
  OutData%GAUSSW = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GAUSSW))-1 ),mask1,OutData%GAUSSW)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%GAUSSW)
  OutData%NGAUSS = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  ALLOCATE(mask2(SIZE(OutData%SHAPT,1),SIZE(OutData%SHAPT,2))); mask2 = .TRUE.
  OutData%SHAPT = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SHAPT))-1 ),mask2,OutData%SHAPT)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%SHAPT)
  ALLOCATE(mask2(SIZE(OutData%SHAPTS,1),SIZE(OutData%SHAPTS,2))); mask2 = .TRUE.
  OutData%SHAPTS = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SHAPTS))-1 ),mask2,OutData%SHAPTS)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%SHAPTS)
  OutData%NTRAP = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  ALLOCATE(mask2(SIZE(OutData%SBEND,1),SIZE(OutData%SBEND,2))); mask2 = .TRUE.
  OutData%SBEND = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SBEND))-1 ),mask2,OutData%SBEND)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%SBEND)
  ALLOCATE(mask3(SIZE(OutData%STEN,1),SIZE(OutData%STEN,2),SIZE(OutData%STEN,3))); mask3 = .TRUE.
  OutData%STEN = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%STEN))-1 ),mask3,OutData%STEN)
  DEALLOCATE(mask3)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%STEN)
  ALLOCATE(mask2(SIZE(OutData%RMASS,1),SIZE(OutData%RMASS,2))); mask2 = .TRUE.
  OutData%RMASS = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%RMASS))-1 ),mask2,OutData%RMASS)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%RMASS)
  ALLOCATE(mask4(SIZE(OutData%RADDM,1),SIZE(OutData%RADDM,2),SIZE(OutData%RADDM,3),SIZE(OutData%RADDM,4))); mask4 = .TRUE.
  OutData%RADDM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%RADDM))-1 ),mask4,OutData%RADDM)
  DEALLOCATE(mask4)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%RADDM)
  ALLOCATE(mask2(SIZE(OutData%PMPN,1),SIZE(OutData%PMPN,2))); mask2 = .TRUE.
  OutData%PMPN = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PMPN))-1 ),mask2,OutData%PMPN)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%PMPN)
  ALLOCATE(mask1(SIZE(OutData%AM,1))); mask1 = .TRUE.
  OutData%AM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%AM))-1 ),mask1,OutData%AM)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%AM)
  ALLOCATE(mask1(SIZE(OutData%PM,1))); mask1 = .TRUE.
  OutData%PM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PM))-1 ),mask1,OutData%PM)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%PM)
  ALLOCATE(mask2(SIZE(OutData%IDOF,1),SIZE(OutData%IDOF,2))); mask2 = .TRUE.
  OutData%IDOF = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDOF))-1 ),mask2,OutData%IDOF)
  DEALLOCATE(mask2)
  Int_Xferred   = Int_Xferred   + SIZE(OutData%IDOF)
  ALLOCATE(mask1(SIZE(OutData%JDOF,1))); mask1 = .TRUE.
  OutData%JDOF = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%JDOF))-1 ),mask1,OutData%JDOF)
  DEALLOCATE(mask1)
  Int_Xferred   = Int_Xferred   + SIZE(OutData%JDOF)
  ALLOCATE(mask3(SIZE(OutData%PPA,1),SIZE(OutData%PPA,2),SIZE(OutData%PPA,3))); mask3 = .TRUE.
  OutData%PPA = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PPA))-1 ),mask3,OutData%PPA)
  DEALLOCATE(mask3)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%PPA)
  OutData%PtfmRefzt = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%OutParam,1), UBOUND(OutData%OutParam,1)
 ! first call NWTC_Library_Packoutparmtype to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, OutData%OutParam(i1), ErrStat, ErrMsg, .TRUE. ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) THEN
    Re_OutParam_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_OutParam_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Db_OutParam_Buf)) THEN
    Db_OutParam_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_OutParam_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Int_OutParam_Buf)) THEN
    Int_OutParam_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_OutParam_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_OutParam_Buf)
  ENDIF
  CALL NWTC_Library_UnPackoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, OutData%OutParam(i1), ErrStat, ErrMsg ) ! OutParam 
ENDDO
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnPackParam

 SUBROUTINE FEAM_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_inputtype), INTENT(INOUT) :: SrcInputData
   TYPE(FEAM_inputtype), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
     CALL MeshCopy( SrcInputData%HydroForceLineMesh, DstInputData%HydroForceLineMesh, CtrlCode, ErrStat, ErrMsg )
     CALL MeshCopy( SrcInputData%PtFairleadDisplacement, DstInputData%PtFairleadDisplacement, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE FEAM_CopyInput

 SUBROUTINE FEAM_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(FEAM_inputtype), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( InputData%HydroForceLineMesh, ErrStat, ErrMsg )
  CALL MeshDestroy( InputData%PtFairleadDisplacement, ErrStat, ErrMsg )
 END SUBROUTINE FEAM_DestroyInput

 SUBROUTINE FEAM_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_inputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_HydroForceLineMesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_HydroForceLineMesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_HydroForceLineMesh_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_PtFairleadDisplacement_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_PtFairleadDisplacement_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_PtFairleadDisplacement_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%HydroForceLineMesh, Re_HydroForceLineMesh_Buf, Db_HydroForceLineMesh_Buf, Int_HydroForceLineMesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! HydroForceLineMesh 
  IF(ALLOCATED(Re_HydroForceLineMesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_HydroForceLineMesh_Buf  ) ! HydroForceLineMesh
  IF(ALLOCATED(Db_HydroForceLineMesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_HydroForceLineMesh_Buf  ) ! HydroForceLineMesh
  IF(ALLOCATED(Int_HydroForceLineMesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_HydroForceLineMesh_Buf ) ! HydroForceLineMesh
  IF(ALLOCATED(Re_HydroForceLineMesh_Buf))  DEALLOCATE(Re_HydroForceLineMesh_Buf)
  IF(ALLOCATED(Db_HydroForceLineMesh_Buf))  DEALLOCATE(Db_HydroForceLineMesh_Buf)
  IF(ALLOCATED(Int_HydroForceLineMesh_Buf)) DEALLOCATE(Int_HydroForceLineMesh_Buf)
  CALL MeshPack( InData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg, .TRUE. ) ! PtFairleadDisplacement 
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_PtFairleadDisplacement_Buf  ) ! PtFairleadDisplacement
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_PtFairleadDisplacement_Buf  ) ! PtFairleadDisplacement
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf))Int_BufSz = Int_BufSz + SIZE( Int_PtFairleadDisplacement_Buf ) ! PtFairleadDisplacement
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf))  DEALLOCATE(Re_PtFairleadDisplacement_Buf)
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf))  DEALLOCATE(Db_PtFairleadDisplacement_Buf)
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf)) DEALLOCATE(Int_PtFairleadDisplacement_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL MeshPack( InData%HydroForceLineMesh, Re_HydroForceLineMesh_Buf, Db_HydroForceLineMesh_Buf, Int_HydroForceLineMesh_Buf, ErrStat, ErrMsg, OnlySize ) ! HydroForceLineMesh 
  IF(ALLOCATED(Re_HydroForceLineMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_HydroForceLineMesh_Buf)-1 ) = Re_HydroForceLineMesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_HydroForceLineMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_HydroForceLineMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_HydroForceLineMesh_Buf)-1 ) = Db_HydroForceLineMesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_HydroForceLineMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_HydroForceLineMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_HydroForceLineMesh_Buf)-1 ) = Int_HydroForceLineMesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_HydroForceLineMesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_HydroForceLineMesh_Buf) )  DEALLOCATE(Re_HydroForceLineMesh_Buf)
  IF( ALLOCATED(Db_HydroForceLineMesh_Buf) )  DEALLOCATE(Db_HydroForceLineMesh_Buf)
  IF( ALLOCATED(Int_HydroForceLineMesh_Buf) ) DEALLOCATE(Int_HydroForceLineMesh_Buf)
  CALL MeshPack( InData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg, OnlySize ) ! PtFairleadDisplacement 
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadDisplacement_Buf)-1 ) = Re_PtFairleadDisplacement_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadDisplacement_Buf)-1 ) = Db_PtFairleadDisplacement_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadDisplacement_Buf)-1 ) = Int_PtFairleadDisplacement_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadDisplacement_Buf)
  ENDIF
  IF( ALLOCATED(Re_PtFairleadDisplacement_Buf) )  DEALLOCATE(Re_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Db_PtFairleadDisplacement_Buf) )  DEALLOCATE(Db_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Int_PtFairleadDisplacement_Buf) ) DEALLOCATE(Int_PtFairleadDisplacement_Buf)
 END SUBROUTINE FEAM_PackInput

 SUBROUTINE FEAM_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_inputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_HydroForceLineMesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_HydroForceLineMesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_HydroForceLineMesh_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_PtFairleadDisplacement_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_PtFairleadDisplacement_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_PtFairleadDisplacement_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%HydroForceLineMesh, Re_HydroForceLineMesh_Buf, Db_HydroForceLineMesh_Buf, Int_HydroForceLineMesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! HydroForceLineMesh 
  IF(ALLOCATED(Re_HydroForceLineMesh_Buf)) THEN
    Re_HydroForceLineMesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_HydroForceLineMesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_HydroForceLineMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_HydroForceLineMesh_Buf)) THEN
    Db_HydroForceLineMesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_HydroForceLineMesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_HydroForceLineMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_HydroForceLineMesh_Buf)) THEN
    Int_HydroForceLineMesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_HydroForceLineMesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_HydroForceLineMesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%HydroForceLineMesh, Re_HydroForceLineMesh_Buf, Db_HydroForceLineMesh_Buf, Int_HydroForceLineMesh_Buf, ErrStat, ErrMsg ) ! HydroForceLineMesh 
  IF( ALLOCATED(Re_HydroForceLineMesh_Buf) )  DEALLOCATE(Re_HydroForceLineMesh_Buf)
  IF( ALLOCATED(Db_HydroForceLineMesh_Buf) )  DEALLOCATE(Db_HydroForceLineMesh_Buf)
  IF( ALLOCATED(Int_HydroForceLineMesh_Buf) ) DEALLOCATE(Int_HydroForceLineMesh_Buf)
  CALL MeshPack( OutData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg , .TRUE. ) ! PtFairleadDisplacement 
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf)) THEN
    Re_PtFairleadDisplacement_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadDisplacement_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf)) THEN
    Db_PtFairleadDisplacement_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadDisplacement_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf)) THEN
    Int_PtFairleadDisplacement_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadDisplacement_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadDisplacement_Buf)
  ENDIF
  CALL MeshUnPack( OutData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg ) ! PtFairleadDisplacement 
  IF( ALLOCATED(Re_PtFairleadDisplacement_Buf) )  DEALLOCATE(Re_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Db_PtFairleadDisplacement_Buf) )  DEALLOCATE(Db_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Int_PtFairleadDisplacement_Buf) ) DEALLOCATE(Int_PtFairleadDisplacement_Buf)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnPackInput

 SUBROUTINE FEAM_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_outputtype), INTENT(INOUT) :: SrcOutputData
   TYPE(FEAM_outputtype), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
   i1_l = LBOUND(SrcOutputData%WriteOutput,1)
   i1_u = UBOUND(SrcOutputData%WriteOutput,1)
   IF (.NOT.ALLOCATED(DstOutputData%WriteOutput)) THEN 
      ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'FEAM_CopyOutput: Error allocating DstOutputData%WriteOutput.'
         RETURN
      END IF
   END IF
   DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
     CALL MeshCopy( SrcOutputData%PtFairleadLoad, DstOutputData%PtFairleadLoad, CtrlCode, ErrStat, ErrMsg )
     CALL MeshCopy( SrcOutputData%LineMeshPosition, DstOutputData%LineMeshPosition, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE FEAM_CopyOutput

 SUBROUTINE FEAM_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(FEAM_outputtype), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OutputData%WriteOutput)) THEN
   DEALLOCATE(OutputData%WriteOutput)
ENDIF
  CALL MeshDestroy( OutputData%PtFairleadLoad, ErrStat, ErrMsg )
  CALL MeshDestroy( OutputData%LineMeshPosition, ErrStat, ErrMsg )
 END SUBROUTINE FEAM_DestroyOutput

 SUBROUTINE FEAM_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_outputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_PtFairleadLoad_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_PtFairleadLoad_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_PtFairleadLoad_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_LineMeshPosition_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_LineMeshPosition_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_LineMeshPosition_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%WriteOutput )  ! WriteOutput 
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg, .TRUE. ) ! PtFairleadLoad 
  IF(ALLOCATED(Re_PtFairleadLoad_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_PtFairleadLoad_Buf  ) ! PtFairleadLoad
  IF(ALLOCATED(Db_PtFairleadLoad_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_PtFairleadLoad_Buf  ) ! PtFairleadLoad
  IF(ALLOCATED(Int_PtFairleadLoad_Buf))Int_BufSz = Int_BufSz + SIZE( Int_PtFairleadLoad_Buf ) ! PtFairleadLoad
  IF(ALLOCATED(Re_PtFairleadLoad_Buf))  DEALLOCATE(Re_PtFairleadLoad_Buf)
  IF(ALLOCATED(Db_PtFairleadLoad_Buf))  DEALLOCATE(Db_PtFairleadLoad_Buf)
  IF(ALLOCATED(Int_PtFairleadLoad_Buf)) DEALLOCATE(Int_PtFairleadLoad_Buf)
  CALL MeshPack( InData%LineMeshPosition, Re_LineMeshPosition_Buf, Db_LineMeshPosition_Buf, Int_LineMeshPosition_Buf, ErrStat, ErrMsg, .TRUE. ) ! LineMeshPosition 
  IF(ALLOCATED(Re_LineMeshPosition_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_LineMeshPosition_Buf  ) ! LineMeshPosition
  IF(ALLOCATED(Db_LineMeshPosition_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_LineMeshPosition_Buf  ) ! LineMeshPosition
  IF(ALLOCATED(Int_LineMeshPosition_Buf))Int_BufSz = Int_BufSz + SIZE( Int_LineMeshPosition_Buf ) ! LineMeshPosition
  IF(ALLOCATED(Re_LineMeshPosition_Buf))  DEALLOCATE(Re_LineMeshPosition_Buf)
  IF(ALLOCATED(Db_LineMeshPosition_Buf))  DEALLOCATE(Db_LineMeshPosition_Buf)
  IF(ALLOCATED(Int_LineMeshPosition_Buf)) DEALLOCATE(Int_LineMeshPosition_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%WriteOutput) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WriteOutput))-1 ) =  PACK(InData%WriteOutput ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WriteOutput)
  ENDIF
  CALL MeshPack( InData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg, OnlySize ) ! PtFairleadLoad 
  IF(ALLOCATED(Re_PtFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadLoad_Buf)-1 ) = Re_PtFairleadLoad_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadLoad_Buf)-1 ) = Db_PtFairleadLoad_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadLoad_Buf)-1 ) = Int_PtFairleadLoad_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadLoad_Buf)
  ENDIF
  IF( ALLOCATED(Re_PtFairleadLoad_Buf) )  DEALLOCATE(Re_PtFairleadLoad_Buf)
  IF( ALLOCATED(Db_PtFairleadLoad_Buf) )  DEALLOCATE(Db_PtFairleadLoad_Buf)
  IF( ALLOCATED(Int_PtFairleadLoad_Buf) ) DEALLOCATE(Int_PtFairleadLoad_Buf)
  CALL MeshPack( InData%LineMeshPosition, Re_LineMeshPosition_Buf, Db_LineMeshPosition_Buf, Int_LineMeshPosition_Buf, ErrStat, ErrMsg, OnlySize ) ! LineMeshPosition 
  IF(ALLOCATED(Re_LineMeshPosition_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LineMeshPosition_Buf)-1 ) = Re_LineMeshPosition_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_LineMeshPosition_Buf)
  ENDIF
  IF(ALLOCATED(Db_LineMeshPosition_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LineMeshPosition_Buf)-1 ) = Db_LineMeshPosition_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_LineMeshPosition_Buf)
  ENDIF
  IF(ALLOCATED(Int_LineMeshPosition_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LineMeshPosition_Buf)-1 ) = Int_LineMeshPosition_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_LineMeshPosition_Buf)
  ENDIF
  IF( ALLOCATED(Re_LineMeshPosition_Buf) )  DEALLOCATE(Re_LineMeshPosition_Buf)
  IF( ALLOCATED(Db_LineMeshPosition_Buf) )  DEALLOCATE(Db_LineMeshPosition_Buf)
  IF( ALLOCATED(Int_LineMeshPosition_Buf) ) DEALLOCATE(Int_LineMeshPosition_Buf)
 END SUBROUTINE FEAM_PackOutput

 SUBROUTINE FEAM_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_outputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_PtFairleadLoad_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_PtFairleadLoad_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_PtFairleadLoad_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_LineMeshPosition_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_LineMeshPosition_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_LineMeshPosition_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%WriteOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WriteOutput,1))); mask1 = .TRUE.
    OutData%WriteOutput = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WriteOutput))-1 ),mask1,OutData%WriteOutput)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WriteOutput)
  ENDIF
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg , .TRUE. ) ! PtFairleadLoad 
  IF(ALLOCATED(Re_PtFairleadLoad_Buf)) THEN
    Re_PtFairleadLoad_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadLoad_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadLoad_Buf)) THEN
    Db_PtFairleadLoad_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadLoad_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadLoad_Buf)) THEN
    Int_PtFairleadLoad_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadLoad_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadLoad_Buf)
  ENDIF
  CALL MeshUnPack( OutData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg ) ! PtFairleadLoad 
  IF( ALLOCATED(Re_PtFairleadLoad_Buf) )  DEALLOCATE(Re_PtFairleadLoad_Buf)
  IF( ALLOCATED(Db_PtFairleadLoad_Buf) )  DEALLOCATE(Db_PtFairleadLoad_Buf)
  IF( ALLOCATED(Int_PtFairleadLoad_Buf) ) DEALLOCATE(Int_PtFairleadLoad_Buf)
  CALL MeshPack( OutData%LineMeshPosition, Re_LineMeshPosition_Buf, Db_LineMeshPosition_Buf, Int_LineMeshPosition_Buf, ErrStat, ErrMsg , .TRUE. ) ! LineMeshPosition 
  IF(ALLOCATED(Re_LineMeshPosition_Buf)) THEN
    Re_LineMeshPosition_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LineMeshPosition_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_LineMeshPosition_Buf)
  ENDIF
  IF(ALLOCATED(Db_LineMeshPosition_Buf)) THEN
    Db_LineMeshPosition_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LineMeshPosition_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_LineMeshPosition_Buf)
  ENDIF
  IF(ALLOCATED(Int_LineMeshPosition_Buf)) THEN
    Int_LineMeshPosition_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LineMeshPosition_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_LineMeshPosition_Buf)
  ENDIF
  CALL MeshUnPack( OutData%LineMeshPosition, Re_LineMeshPosition_Buf, Db_LineMeshPosition_Buf, Int_LineMeshPosition_Buf, ErrStat, ErrMsg ) ! LineMeshPosition 
  IF( ALLOCATED(Re_LineMeshPosition_Buf) )  DEALLOCATE(Re_LineMeshPosition_Buf)
  IF( ALLOCATED(Db_LineMeshPosition_Buf) )  DEALLOCATE(Db_LineMeshPosition_Buf)
  IF( ALLOCATED(Int_LineMeshPosition_Buf) ) DEALLOCATE(Int_LineMeshPosition_Buf)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnPackOutput

 SUBROUTINE FEAM_Pack( Re_RetAry, Db_RetAry, Int_RetAry, &
                     InData, ParamData, ContStateData, DiscStateData, &
                     ConstrStateData, OtherStateData, OutData, ErrStat, ErrMsg, &
                     SizeOnly )
  TYPE(FEAM_InputType),           INTENT(INOUT) :: InData
  TYPE(FEAM_ParameterType),       INTENT(INOUT) :: ParamData
  TYPE(FEAM_ContinuousStateType), INTENT(INOUT) :: ContStateData
  TYPE(FEAM_DiscreteStateType),   INTENT(INOUT) :: DiscStateData
  TYPE(FEAM_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  TYPE(FEAM_OtherStateType),      INTENT(INOUT) :: OtherStateData
  TYPE(FEAM_OutputType),          INTENT(INOUT) :: OutData
  REAL(ReKi), ALLOCATABLE,      INTENT(  OUT) :: Re_RetAry(:)
  REAL(DbKi), ALLOCATABLE,      INTENT(  OUT) :: Db_RetAry(:)
  INTEGER(IntKi), ALLOCATABLE,  INTENT(  OUT) :: Int_RetAry(:)
  INTEGER(IntKi),               INTENT(  OUT) :: ErrStat
  CHARACTER(*),                 INTENT(  OUT) :: ErrMsg
  LOGICAL, OPTIONAL,            INTENT(IN   ) :: SizeOnly
    ! Local variables
  REAL(ReKi), ALLOCATABLE                :: Re_Ary(:)
  REAL(DbKi), ALLOCATABLE                :: Db_Ary(:)
  INTEGER(IntKi), ALLOCATABLE            :: Int_Ary(:)
  INTEGER(IntKi)                         :: Re_BufSz
  INTEGER(IntKi)                         :: Re_Xferred
  INTEGER(IntKi)                         :: Re_CurrSz
  INTEGER(IntKi)                         :: Db_BufSz
  INTEGER(IntKi)                         :: Db_Xferred
  INTEGER(IntKi)                         :: Db_CurrSz
  INTEGER(IntKi)                         :: Int_BufSz
  INTEGER(IntKi)                         :: Int_Xferred
  INTEGER(IntKi)                         :: Int_CurrSz
  INTEGER(IntKi)                         :: ErrStat2
  CHARACTER(Len(ErrMsg))                 :: ErrMsg2
  LOGICAL                                :: OnlySize ! if present and true, do not pack, just allocate buffers
    ! Executable statements
  ErrStat = ErrID_None
  ErrMsg  = ""
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    ! Pack Input
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Param
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ContState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack DiscState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ConstrState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack OtherState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Output
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
  Re_Xferred  = Re_Xferred - 1
  Db_Xferred  = Db_Xferred - 1
  Int_Xferred  = Int_Xferred - 1
  IF ( ALLOCATED( Re_RetAry ) ) DEALLOCATE( Re_RetAry ) ;
  IF ( Re_Xferred .GT. 0) ALLOCATE( Re_RetAry( Re_Xferred ) ) ;
  IF ( ALLOCATED( Db_RetAry ) ) DEALLOCATE( Db_RetAry ) ;
  IF ( Db_Xferred .GT. 0) ALLOCATE( Db_RetAry( Db_Xferred ) ) ;
  IF ( ALLOCATED( Int_RetAry ) ) DEALLOCATE( Int_RetAry ) ;
  IF ( Int_Xferred .GT. 0) ALLOCATE( Int_RetAry( Int_Xferred ) ) ;
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    ! Pack Input
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Param
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ContState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack DiscState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ConstrState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack OtherState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Output
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
  Re_Xferred   = Re_Xferred - 1
  Db_Xferred   = Db_Xferred - 1
  Int_Xferred  = Int_Xferred - 1
 END SUBROUTINE FEAM_Pack

 SUBROUTINE FEAM_UnPack( Re_RetAry, Db_RetAry, Int_RetAry, &
                     InData, ParamData, ContStateData, DiscStateData, &
                     ConstrStateData, OtherStateData, OutData, ErrStat, ErrMsg )
  TYPE(FEAM_InputType),           INTENT(INOUT) :: InData
  TYPE(FEAM_ParameterType),       INTENT(INOUT) :: ParamData
  TYPE(FEAM_ContinuousStateType), INTENT(INOUT) :: ContStateData
  TYPE(FEAM_DiscreteStateType),   INTENT(INOUT) :: DiscStateData
  TYPE(FEAM_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  TYPE(FEAM_OtherStateType),      INTENT(INOUT) :: OtherStateData
  TYPE(FEAM_OutputType),          INTENT(INOUT) :: OutData
  REAL(ReKi), ALLOCATABLE,      INTENT(IN   ) :: Re_RetAry(:)
  REAL(DbKi), ALLOCATABLE,      INTENT(IN   ) :: Db_RetAry(:)
  INTEGER(IntKi), ALLOCATABLE,   INTENT(IN   ) :: Int_RetAry(:)
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  REAL(ReKi), ALLOCATABLE                :: Re_Ary(:)
  REAL(DbKi), ALLOCATABLE                :: Db_Ary(:)
  INTEGER(IntKi), ALLOCATABLE            :: Int_Ary(:)
  INTEGER(IntKi)                         :: Re_BufSz
  INTEGER(IntKi)                         :: Re_Xferred
  INTEGER(IntKi)                         :: Re_CurrSz
  INTEGER(IntKi)                         :: Db_BufSz
  INTEGER(IntKi)                         :: Db_Xferred
  INTEGER(IntKi)                         :: Db_CurrSz
  INTEGER(IntKi)                         :: Int_BufSz
  INTEGER(IntKi)                         :: Int_Xferred
  INTEGER(IntKi)                         :: Int_CurrSz
  INTEGER(IntKi)                         :: ErrStat2
  CHARACTER(Len(ErrMsg))                 :: ErrMsg2
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    ! UnPack Input
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL FEAM_UnPackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack Param
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL FEAM_UnPackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack ContState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL FEAM_UnPackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack DiscState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL FEAM_UnPackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack ConstrState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL FEAM_UnPackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack OtherState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL FEAM_UnPackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack Output
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL FEAM_UnPackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnPack


 SUBROUTINE FEAM_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(FEAM_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(FEAM_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in FEAM_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  CALL MeshCopy(u(1)%HydroForceLineMesh, u_out%HydroForceLineMesh, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshCopy(u(1)%PtFairleadDisplacement, u_out%PtFairleadDisplacement, MESH_UPDATECOPY, ErrStat, ErrMsg )
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp1(u(1)%HydroForceLineMesh, u(2)%HydroForceLineMesh, tin, u_out%HydroForceLineMesh, tin_out, ErrStat, ErrMsg )
  CALL MeshExtrapInterp1(u(1)%PtFairleadDisplacement, u(2)%PtFairleadDisplacement, tin, u_out%PtFairleadDisplacement, tin_out, ErrStat, ErrMsg )
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp2(u(1)%HydroForceLineMesh, u(2)%HydroForceLineMesh, u(3)%HydroForceLineMesh, tin, u_out%HydroForceLineMesh, tin_out, ErrStat, ErrMsg )
  CALL MeshExtrapInterp2(u(1)%PtFairleadDisplacement, u(2)%PtFairleadDisplacement, u(3)%PtFairleadDisplacement, tin, u_out%PtFairleadDisplacement, tin_out, ErrStat, ErrMsg )
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in FEAM_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE FEAM_Input_ExtrapInterp


 SUBROUTINE FEAM_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(FEAM_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(FEAM_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in FEAM_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  u_out%WriteOutput = u(1)%WriteOutput
END IF ! check if allocated
  CALL MeshCopy(u(1)%PtFairleadLoad, u_out%PtFairleadLoad, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshCopy(u(1)%LineMeshPosition, u_out%LineMeshPosition, MESH_UPDATECOPY, ErrStat, ErrMsg )
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = -(u(1)%WriteOutput - u(2)%WriteOutput)/t(2)
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  CALL MeshExtrapInterp1(u(1)%PtFairleadLoad, u(2)%PtFairleadLoad, tin, u_out%PtFairleadLoad, tin_out, ErrStat, ErrMsg )
  CALL MeshExtrapInterp1(u(1)%LineMeshPosition, u(2)%LineMeshPosition, tin, u_out%LineMeshPosition, tin_out, ErrStat, ErrMsg )
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = (t(3)**2*(u(1)%WriteOutput - u(2)%WriteOutput) + t(2)**2*(-u(1)%WriteOutput + u(3)%WriteOutput))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%WriteOutput + t(3)*u(2)%WriteOutput - t(2)*u(3)%WriteOutput ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  CALL MeshExtrapInterp2(u(1)%PtFairleadLoad, u(2)%PtFairleadLoad, u(3)%PtFairleadLoad, tin, u_out%PtFairleadLoad, tin_out, ErrStat, ErrMsg )
  CALL MeshExtrapInterp2(u(1)%LineMeshPosition, u(2)%LineMeshPosition, u(3)%LineMeshPosition, tin, u_out%LineMeshPosition, tin_out, ErrStat, ErrMsg )
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in FEAM_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE FEAM_Output_ExtrapInterp

END MODULE FEAMooring_Types
!ENDOFREGISTRYGENERATEDFILE
